<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>钢铁侠粒子操控 (纯净版)</title>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    <style>
        body { margin: 0; background: #000; overflow: hidden; font-family: sans-serif; }
        
        /* 隐藏原始 video 标签 */
        video { display: none; }
        
        /* 画布全屏 */
        canvas { 
            position: absolute; 
            width: 100%; 
            height: 100%; 
            transform: scaleX(-1); /* 镜像翻转，操作更自然 */
        }

        /* 底部素材库 */
        #gallery-container {
            position: absolute; bottom: 0; left: 0; width: 100%; height: 100px;
            background: linear-gradient(to top, #000, transparent); /* 渐变黑 */
            display: flex; align-items: center;
            overflow-x: auto; padding: 0 10px; box-sizing: border-box; z-index: 100;
        }
        .gallery-item {
            height: 70px; width: 70px; object-fit: cover; margin-right: 15px;
            border-radius: 8px; cursor: pointer; border: 2px solid #333;
            transition: all 0.3s; flex-shrink: 0; opacity: 0.7;
        }
        .gallery-item:hover { transform: scale(1.1); opacity: 1; }
        .gallery-item.selected { border-color: #00ffff; opacity: 1; box-shadow: 0 0 10px #00ffff; }
        
        /* 顶部状态栏 */
        #status-bar {
            position: absolute; top: 30px; left: 50%; transform: translateX(-50%) scaleX(-1);
            color: rgba(255,255,255,0.8); 
            font-size: 14px; letter-spacing: 2px;
            pointer-events: none; z-index: 50; 
            text-shadow: 0 0 5px rgba(255,255,255,0.5);
        }
    </style>
</head>
<body>

    <div id="status-bar">SYSTEM READY</div>

    <video id="input_video"></video>
    <canvas id="output_canvas"></canvas>

    <div id="gallery-container">
        <div style="color:#666;width:100%;text-align:center;font-size:12px;">连接云端数据库...</div>
    </div>

<script>
    const videoElement = document.getElementById('input_video');
    const canvasElement = document.getElementById('output_canvas');
    const ctx = canvasElement.getContext('2d');
    const statusEl = document.getElementById('status-bar');

    let MODE = 'TREE'; 
    let imgObj = new Image(); imgObj.src = "";
    let imgState = { x: 0.5, y: 0.5, scale: 0, opacity: 0 };

    // --- 手势检测 ---
    function detectGesture(landmarks) {
        const wrist = landmarks[0];
        const tips = [8, 12, 16, 20];
        let foldedFingers = 0;
        tips.forEach(idx => {
            if (Math.hypot(landmarks[idx].x - wrist.x, landmarks[idx].y - wrist.y) < 0.35) foldedFingers++; 
        });
        const isPinch = Math.hypot(landmarks[4].x - landmarks[8].x, landmarks[4].y - landmarks[8].y) < 0.05;

        if (isPinch) return 'PINCH';
        if (foldedFingers >= 3) return 'FIST';
        if (foldedFingers <= 1) return 'OPEN';
        return 'UNKNOWN';
    }

    // --- 粒子系统 ---
    class Particle {
        constructor() {
            this.x = Math.random() * canvasElement.width;
            this.y = Math.random() * canvasElement.height;
            this.tx = this.x; this.ty = this.y;
            this.color = '#FFD700'; 
            this.baseSize = Math.random() * 2 + 1;
            this.treeY = Math.random(); 
            this.treeAngle = Math.random() * Math.PI * 2;
        }

        update(centerX, centerY, treeHeight) {
            if (MODE === 'TREE') {
                const maxRadius = treeHeight * 0.4 * (1 - this.treeY);
                this.tx = centerX + Math.cos(this.treeAngle) * maxRadius;
                this.ty = centerY + (this.treeY - 0.5) * -treeHeight;
                this.treeAngle += 0.02;
                this.color = `hsl(50, 100%, ${50 + Math.random()*30}%)`; // 闪烁金色
            } else if (MODE === 'EXPLODE') {
                this.treeAngle += 0.005;
                const radius = treeHeight * 1.5;
                this.tx = centerX + Math.cos(this.treeAngle * 3 + this.treeY * 10) * radius * (this.treeY + 0.2);
                this.ty = centerY + Math.sin(this.treeAngle * 2 + this.treeY * 10) * radius * (this.treeY + 0.2);
                this.color = `hsl(${this.treeY * 360}, 70%, 60%)`; // 彩色星云
            }
            this.x += (this.tx - this.x) * 0.1;
            this.y += (this.ty - this.y) * 0.1;
        }

        draw(ctx) {
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.baseSize, 0, Math.PI * 2);
            ctx.fillStyle = this.color;
            ctx.fill();
        }
    }

    const particles = [];
    for(let i=0; i<800; i++) particles.push(new Particle());

    // --- 渲染循环 ---
    function onResults(results) {
        // 设置画布尺寸
        canvasElement.width = window.innerWidth;
        canvasElement.height = window.innerHeight;
        
        // 1. 清空画布 (画纯黑背景，不再画 results.image)
        ctx.fillStyle = "#000000";
        ctx.fillRect(0, 0, canvasElement.width, canvasElement.height);
        
        // 2. 绘制一些背景微光 (可选，增加氛围感)
        // ctx.globalCompositeOperation = 'lighter'; // 粒子发光

        let handCenter = { x: canvasElement.width/2, y: canvasElement.height/2 };
        let gesture = 'UNKNOWN';

        if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
            const landmarks = results.multiHandLandmarks[0];
            gesture = detectGesture(landmarks);
            
            handCenter.x = (landmarks[9].x + landmarks[0].x) / 2 * canvasElement.width;
            handCenter.y = (landmarks[9].y + landmarks[0].y) / 2 * canvasElement.height;

            if (gesture === 'FIST') {
                MODE = 'TREE';
                statusEl.innerText = "FIST DETECTED: FORMING TREE";
                statusEl.style.color = "#FFD700";
                imgState.opacity *= 0.8; 
            } else if (gesture === 'OPEN') {
                MODE = 'EXPLODE';
                statusEl.innerText = "OPEN HAND: DISPERSING PARTICLES";
                statusEl.style.color = "#00ffff";
                imgState.opacity *= 0.8;
            } else if (gesture === 'PINCH') {
                statusEl.innerText = "PINCH: INTERACTING WITH PHOTO";
                statusEl.style.color = "#ff00ff";
                
                const thumb = landmarks[4];
                const index = landmarks[8];
                const pinchX = (thumb.x + index.x) / 2 * canvasElement.width;
                const pinchY = (thumb.y + index.y) / 2 * canvasElement.height;
                
                imgState.x += (pinchX - imgState.x) * 0.15;
                imgState.y += (pinchY - imgState.y) * 0.15;
                imgState.opacity += (1 - imgState.opacity) * 0.1;
                imgState.scale += (1 - imgState.scale) * 0.1;
            }
        } else {
            statusEl.innerText = "NO SIGNAL - WAITING FOR HAND";
            statusEl.style.color = "#444";
        }

        // 3. 绘制粒子
        particles.forEach(p => {
            p.update(handCenter.x, handCenter.y, canvasElement.height * 0.5);
            p.draw(ctx);
        });

        // 4. 绘制照片
        if (imgObj.src && imgObj.complete && imgState.opacity > 0.01) {
            ctx.save();
            ctx.globalAlpha = imgState.opacity;
            
            const aspectRatio = imgObj.naturalWidth / imgObj.naturalHeight || 1;
            const drawW = 300 * Math.max(0.5, imgState.scale); 
            const drawH = drawW / aspectRatio;
            const drawX = imgState.x - drawW/2;
            const drawY = imgState.y - drawH/2;

            ctx.drawImage(imgObj, drawX, drawY, drawW, drawH);
            
            ctx.strokeStyle = "cyan";
            ctx.lineWidth = 2;
            ctx.shadowColor = "cyan";
            ctx.shadowBlur = 15;
            ctx.strokeRect(drawX, drawY, drawW, drawH);

            ctx.restore();
        }
    }

    const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
    hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });
    hands.onResults(onResults);
    const camera = new Camera(videoElement, { onFrame: async () => { await hands.send({image: videoElement}); }, width: 1280, height: 720 });
    camera.start();

    async function loadGallery() {
        const container = document.getElementById('gallery-container');
        try {
            const res = await fetch('/api/images');
            const images = await res.json();
            container.innerHTML = '';
            if(images.length === 0) { container.innerHTML = '<div style="color:#666;margin:auto">暂无素材</div>'; return; }

            images.forEach((data, idx) => {
                const el = document.createElement('img');
                el.src = data.url;
                el.className = 'gallery-item';
                el.onclick = () => {
                    document.querySelectorAll('.gallery-item').forEach(e=>e.classList.remove('selected'));
                    el.classList.add('selected');
                    imgObj.crossOrigin = "Anonymous";
                    imgObj.src = data.url + "?t=" + Date.now();
                };
                if(idx===0) el.click();
                container.appendChild(el);
            });
        } catch(e) { console.error(e); container.innerHTML = '<div style="color:red;margin:auto">Offline</div>'; }
    }
    loadGallery();
</script>
</body>
</html>