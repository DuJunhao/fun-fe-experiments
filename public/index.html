<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å¥¢åæµé‡‘åœ£è¯æ ‘ AR</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: sans-serif; user-select: none; }
        #canvas-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; }

        /* UI é¢æ¿ */
        #ui-panel {
            position: absolute; top: 20px; left: 20px; width: 180px;
            background: rgba(10, 10, 10, 0.6); backdrop-filter: blur(8px);
            padding: 15px; border-radius: 8px; color: #d4af37; z-index: 10;
            border: 1px solid rgba(212, 175, 55, 0.3);
            box-shadow: 0 0 20px rgba(212, 175, 55, 0.1);
        }
        .ui-label { font-size: 10px; letter-spacing: 2px; color: #888; margin-bottom: 8px; font-weight: bold; }
        .status-text { font-size: 14px; color: #fff; text-shadow: 0 0 5px gold; }

        /* åº•éƒ¨ç…§ç‰‡æ  */
        #gallery-container {
            position: absolute; bottom: 0; left: 0; width: 100%; height: 110px;
            background: linear-gradient(to top, #000, transparent);
            display: flex; align-items: center; overflow-x: auto; padding: 0 20px; z-index: 10; gap: 15px;
        }
        .gallery-item {
            height: 70px; width: 70px; object-fit: cover;
            border-radius: 4px; cursor: pointer; border: 1px solid #444;
            transition: all 0.3s; flex-shrink: 0; opacity: 0.6;
        }
        .gallery-item:hover { transform: scale(1.1); opacity: 1; border-color: gold; }
        .gallery-item.selected { border-color: gold; opacity: 1; box-shadow: 0 0 15px gold; transform: scale(1.1); }
        
        #loading-text { color: #888; font-size: 12px; width: 100%; text-align: center; }
        
        video { display: none; }
    </style>
</head>
<body>

    <div id="ui-panel">
        <div class="ui-label">STATUS</div>
        <div id="status-text" class="status-text">INITIALIZING...</div>
        <div class="ui-label" style="margin-top:15px">GESTURES</div>
        <div style="font-size:12px; color:#aaa;">âœŠ æ¡æ‹³: èšåˆæˆæ ‘</div>
        <div style="font-size:12px; color:#aaa;">ğŸ– å¼ å¼€: é‡‘ç²‰çˆ†ç‚¸</div>
        <div style="font-size:12px; color:#aaa;">ğŸ‘Œ æåˆ: æŠ“å–ç…§ç‰‡</div>
    </div>

    <div id="canvas-container"></div>
    <video id="input_video"></video>

    <div id="gallery-container">
        <div id="loading-text">æ­£åœ¨ä» Cloud Run è·å–åˆ—è¡¨...</div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <script>
        // ================= å…¨å±€å˜é‡ =================
        let scene, camera, renderer, goldParticles, itemParticles, photoMesh;
        let handOpenFactor = 0; // 0=æ ‘(æ¡æ‹³), 1=çˆ†ç‚¸(å¼ å¼€)
        let isMouseMode = false;
        let isPhotoMode = false;
        
        // ç²’å­æ•°é‡
        const GOLD_COUNT = 25000;
        const ITEM_COUNT = 300; 

        // ================= è¾…åŠ©ï¼šç¨‹åºåŒ–ç”Ÿæˆçº¹ç† (é˜²æ­¢Base64è·¨åŸŸ/åŠ è½½å¤±è´¥) =================
        function createSparkTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 32; canvas.height = 32;
            const context = canvas.getContext('2d');
            const gradient = context.createRadialGradient(16, 16, 0, 16, 16, 16);
            gradient.addColorStop(0, 'rgba(255,255,255,1)');
            gradient.addColorStop(0.2, 'rgba(255,215,0,1)');
            gradient.addColorStop(0.5, 'rgba(255,215,0,0.2)');
            gradient.addColorStop(1, 'rgba(0,0,0,0)');
            context.fillStyle = gradient;
            context.fillRect(0, 0, 32, 32);
            const tex = new THREE.CanvasTexture(canvas);
            tex.needsUpdate = true;
            return tex;
        }

        // ================= Three.js åˆå§‹åŒ– =================
        function initThree() {
            const container = document.getElementById('canvas-container');
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x000000, 0.001); // é»‘è‰²è¿·é›¾

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);
            camera.position.z = 100;

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.outputEncoding = THREE.sRGBEncoding;
            container.appendChild(renderer.domElement);

            // ç”Ÿæˆçº¹ç†
            const sparkTexture = createSparkTexture();
            
            // --- ç³»ç»Ÿ1: é‡‘ç²‰ç²’å­ (ç»„æˆæ ‘çš„ä¸»ä½“) ---
            const goldGeo = new THREE.BufferGeometry();
            const goldPos = new Float32Array(GOLD_COUNT * 3);
            const goldTarget = new Float32Array(GOLD_COUNT * 3);
            const goldOffset = new Float32Array(GOLD_COUNT * 3);
            const goldColor = new Float32Array(GOLD_COUNT * 3);

            for(let i=0; i<GOLD_COUNT; i++) {
                const i3 = i*3;
                goldPos[i3]=0; goldPos[i3+1]=0; goldPos[i3+2]=0;
                
                // æ ‘å½¢ç›®æ ‡ (èºæ—‹åœ†é”¥)
                const h = Math.random(); // 0-1
                const angle = h * Math.PI * 18; 
                const r = (1-h) * 35 + Math.random()*2;
                goldTarget[i3] = Math.cos(angle)*r;
                goldTarget[i3+1] = (h-0.5)*90;
                goldTarget[i3+2] = Math.sin(angle)*r;

                // çˆ†ç‚¸åç§»
                goldOffset[i3] = (Math.random()-0.5)*2;
                goldOffset[i3+1] = (Math.random()-0.5)*2;
                goldOffset[i3+2] = (Math.random()-0.5)*2;

                // é¢œè‰²ï¼šé‡‘è‰²ä¸ºä¸»ï¼Œæ··å…¥å°‘é‡çº¢/ç™½
                const colorType = Math.random();
                const col = new THREE.Color();
                if(colorType > 0.9) col.setHex(0xFFFFFF); // ç™½é’»
                else if(colorType > 0.8) col.setHex(0xFF0000); // çº¢å®çŸ³
                else col.setHex(0xFFD700); // çº¯é‡‘
                
                goldColor[i3] = col.r; goldColor[i3+1] = col.g; goldColor[i3+2] = col.b;
            }
            goldGeo.setAttribute('position', new THREE.BufferAttribute(goldPos, 3));
            goldGeo.setAttribute('aTarget', new THREE.BufferAttribute(goldTarget, 3));
            goldGeo.setAttribute('aOffset', new THREE.BufferAttribute(goldOffset, 3));
            goldGeo.setAttribute('color', new THREE.BufferAttribute(goldColor, 3));

            const goldMat = new THREE.ShaderMaterial({
                uniforms: {
                    uTime: { value: 0 },
                    uFactor: { value: 0 },
                    uTex: { value: sparkTexture },
                    uIsPhoto: { value: 0 }
                },
                vertexShader: `
                    uniform float uTime;
                    uniform float uFactor; // 0=æ ‘, 1=ç‚¸
                    uniform float uIsPhoto;
                    attribute vec3 aTarget;
                    attribute vec3 aOffset;
                    attribute vec3 color;
                    varying vec3 vColor;
                    void main() {
                        vColor = color;
                        // æ ‘å½¢æ€
                        vec3 posTree = aTarget;
                        // åŠ ä¸Šæ—‹è½¬
                        float angle = uTime * 0.2;
                        float ca = cos(angle); float sa = sin(angle);
                        posTree.x = aTarget.x * ca - aTarget.z * sa;
                        posTree.z = aTarget.x * sa + aTarget.z * ca;

                        // çˆ†ç‚¸å½¢æ€
                        vec3 posExp = aTarget + normalize(aOffset) * (80.0 + sin(uTime*3.0+aOffset.x)*10.0);
                        
                        // æœ€ç»ˆæ··åˆ (ç…§ç‰‡æ¨¡å¼æ—¶å¼ºåˆ¶æ•£å¼€)
                        float finalFactor = mix(uFactor, 1.0, uIsPhoto * 0.9);
                        vec3 finalPos = mix(posTree, posExp, finalFactor);
                        
                        vec4 mvPosition = modelViewMatrix * vec4(finalPos, 1.0);
                        gl_Position = projectionMatrix * mvPosition;
                        gl_PointSize = (4.0 * (1.0+finalFactor)) * (300.0 / -mvPosition.z);
                    }
                `,
                fragmentShader: `
                    uniform sampler2D uTex;
                    varying vec3 vColor;
                    void main() {
                        vec4 tex = texture2D(uTex, gl_PointCoord);
                        if(tex.a < 0.1) discard;
                        gl_FragColor = vec4(vColor, tex.a);
                    }
                `,
                transparent: true,
                depthWrite: false,
                blending: THREE.AdditiveBlending // å…³é”®ï¼šå‘å…‰å åŠ 
            });
            goldParticles = new THREE.Points(goldGeo, goldMat);
            scene.add(goldParticles);

            // --- ç³»ç»Ÿ2: æ°›å›´æ¼‚æµ®ç‰© (ç¤¼ç‰©ã€ä¿¡å° - ç”¨Shaderç”»æ–¹å—) ---
            const itemGeo = new THREE.BufferGeometry();
            const itemPos = new Float32Array(ITEM_COUNT * 3);
            const itemOffset = new Float32Array(ITEM_COUNT * 3);
            for(let i=0; i<ITEM_COUNT; i++) {
                itemPos[i*3]=0; itemPos[i*3+1]=0; itemPos[i*3+2]=0;
                const r = 20 + Math.random()*40;
                const theta = Math.random()*Math.PI*2;
                const y = (Math.random()-0.5)*100;
                itemOffset[i*3] = Math.cos(theta)*r;
                itemOffset[i*3+1] = y;
                itemOffset[i*3+2] = Math.sin(theta)*r;
            }
            itemGeo.setAttribute('position', new THREE.BufferAttribute(itemPos, 3));
            itemGeo.setAttribute('aBasePos', new THREE.BufferAttribute(itemOffset, 3));

            const itemMat = new THREE.ShaderMaterial({
                uniforms: { uTime: { value: 0 }, uFactor: { value: 0 }, uIsPhoto: { value: 0 } },
                vertexShader: `
                    uniform float uTime;
                    uniform float uFactor;
                    uniform float uIsPhoto;
                    attribute vec3 aBasePos;
                    void main() {
                        float angle = uTime * 0.1 + aBasePos.y * 0.05;
                        vec3 pos;
                        pos.x = aBasePos.x * cos(angle) - aBasePos.z * sin(angle);
                        pos.z = aBasePos.x * sin(angle) + aBasePos.z * cos(angle);
                        pos.y = aBasePos.y + sin(uTime + aBasePos.x)*5.0;

                        float finalFactor = mix(uFactor, 1.0, uIsPhoto);
                        vec3 finalPos = pos * (0.5 + finalFactor * 1.5);

                        vec4 mvPosition = modelViewMatrix * vec4(finalPos, 1.0);
                        gl_Position = projectionMatrix * mvPosition;
                        gl_PointSize = 12.0 * (300.0 / -mvPosition.z);
                    }
                `,
                fragmentShader: `
                    void main() {
                        // ç»˜åˆ¶å°æ–¹å— (ç¤¼ç‰©)
                        vec2 coord = gl_PointCoord - vec2(0.5);
                        if(abs(coord.x) > 0.4 || abs(coord.y) > 0.4) discard;
                        gl_FragColor = vec4(1.0, 0.2, 0.2, 0.8); // çº¢è‰²
                    }
                `,
                transparent: true
            });
            itemParticles = new THREE.Points(itemGeo, itemMat);
            scene.add(itemParticles);

            // --- ç…§ç‰‡å±•ç¤ºå¹³é¢ ---
            photoMesh = new THREE.Mesh(
                new THREE.PlaneGeometry(1,1),
                new THREE.MeshBasicMaterial({ transparent: true, opacity: 0, side: THREE.DoubleSide })
            );
            scene.add(photoMesh);

            window.addEventListener('resize', onResize);
        }

        function onResize() {
            camera.aspect = window.innerWidth/window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // ================= äº¤äº’é€»è¾‘ =================
        async function loadGallery() {
            const container = document.getElementById('gallery-container');
            const status = document.getElementById('loading-text');
            try {
                // è¯·æ±‚ Node.js åç«¯
                const res = await fetch('/api/images');
                const images = await res.json();
                
                container.innerHTML = '';
                if(images.length === 0) { status.innerText = "Bucketä¸ºç©º"; return; }

                images.forEach((imgData, idx) => {
                    const el = document.createElement('img');
                    el.src = imgData.url + "?t=" + Date.now(); // ä¿®æ­£ç¼“å­˜
                    el.className = 'gallery-item';
                    el.onclick = () => {
                        document.querySelectorAll('.gallery-item').forEach(e=>e.classList.remove('selected'));
                        el.classList.add('selected');
                        showPhoto(imgData.url);
                    };
                    if(idx===0) el.click();
                    container.appendChild(el);
                });
            } catch(e) {
                console.error(e);
                status.innerText = "è¿æ¥åç«¯å¤±è´¥";
            }
        }

        function showPhoto(url) {
            isPhotoMode = true;
            const loader = new THREE.TextureLoader();
            loader.crossOrigin = "Anonymous";
            loader.load(url + "?t=" + Date.now(), (tex) => {
                const aspect = tex.image.width / tex.image.height;
                photoMesh.geometry.dispose();
                photoMesh.geometry = new THREE.PlaneGeometry(40*aspect, 40);
                photoMesh.material.map = tex;
                photoMesh.material.needsUpdate = true;
            });
        }

        // MediaPipe
        function initMediaPipe() {
            const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
            hands.setOptions({maxNumHands: 1, modelComplexity: 0, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5});
            
            hands.onResults(results => {
                if(results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                    isMouseMode = false;
                    const lm = results.multiHandLandmarks[0];
                    const d = Math.hypot(lm[8].x - lm[0].x, lm[8].y - lm[0].y); 
                    let target = (d - 0.2) * 3.3; 
                    handOpenFactor += (Math.max(0, Math.min(1, target)) - handOpenFactor) * 0.1;
                    
                    const status = document.getElementById('status-text');
                    if(handOpenFactor < 0.3) status.innerText = "STATUS: FORMING TREE";
                    else status.innerText = "STATUS: EXPLODING";
                    
                    const pinch = Math.hypot(lm[4].x-lm[8].x, lm[4].y-lm[8].y);
                    if(pinch < 0.05) status.innerText = "STATUS: VIEW PHOTO";
                } else if(!isMouseMode) {
                    handOpenFactor += (0 - handOpenFactor) * 0.05;
                    document.getElementById('status-text').innerText = "WAITING FOR HAND...";
                }
            });

            const cam = new Camera(document.getElementById('input_video'), {
                onFrame: async () => { await hands.send({image: document.getElementById('input_video')}); },
                width: 320, height: 240
            });
            
            // é™é»˜å¤±è´¥å¤„ç†
            cam.start().catch(() => {
                console.log("Camera failed, switching to mouse mode");
                isMouseMode = true;
                document.getElementById('status-text').innerText = "MOUSE MODE ACTIVE";
                // é¼ æ ‡æ¨¡æ‹Ÿ
                document.addEventListener('mousemove', (e) => {
                    handOpenFactor = 1.0 - (e.clientY / window.innerHeight);
                });
            });
        }

        function animate() {
            requestAnimationFrame(animate);
            const time = Date.now() * 0.001;

            if(goldParticles) {
                goldParticles.material.uniforms.uTime.value = time;
                goldParticles.material.uniforms.uFactor.value = handOpenFactor;
                goldParticles.material.uniforms.uIsPhoto.value += ((isPhotoMode?1:0) - goldParticles.material.uniforms.uIsPhoto.value)*0.1;
                
                itemParticles.material.uniforms.uTime.value = time;
                itemParticles.material.uniforms.uFactor.value = handOpenFactor;
                itemParticles.material.uniforms.uIsPhoto.value = goldParticles.material.uniforms.uIsPhoto.value;
            }

            if(photoMesh) {
                const targetOp = isPhotoMode ? 1.0 : 0.0;
                photoMesh.material.opacity += (targetOp - photoMesh.material.opacity) * 0.1;
                if(isPhotoMode) {
                    photoMesh.position.y = Math.sin(time)*1.0; 
                    photoMesh.rotation.y = Math.sin(time*0.5)*0.1;
                }
            }

            renderer.render(scene, camera);
        }

        // å¯åŠ¨
        initThree();
        initMediaPipe();
        loadGallery();
        animate(); // ç¡®ä¿ç«‹åˆ»å¯åŠ¨å¾ªç¯

    </script>
</body>
</html>