<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Â•¢ÂçéÂõûÂøÜÂú£ËØûÊ†ë AR (Ëá™ÈÄÇÂ∫îÁâà)</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Arial', sans-serif; user-select: none; }
        #canvas-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; }

        /* UI Èù¢Êùø - ÊûÅÁÆÄÂ•¢ÂçéÈ£é */
        #ui-panel {
            position: absolute; top: 20px; left: 20px; width: 200px;
            background: linear-gradient(135deg, rgba(20,20,20,0.8), rgba(10,10,10,0.9));
            backdrop-filter: blur(10px);
            padding: 15px; border-radius: 4px; color: #d4af37; z-index: 10;
            border-left: 2px solid #d4af37;
            box-shadow: 0 4px 30px rgba(0,0,0,0.5);
        }
        .ui-label { font-size: 9px; letter-spacing: 2px; color: #666; margin-bottom: 5px; font-weight: bold; text-transform: uppercase; }
        .status-text { font-size: 12px; color: #fff; text-shadow: 0 0 5px rgba(212, 175, 55, 0.5); margin-bottom: 15px; font-family: monospace;}
        .hint { font-size: 11px; color: #999; margin-bottom: 3px; display: flex; align-items: center; gap: 5px; }

        /* Â∫ïÈÉ®ÁÖßÁâáÊ†è */
        #gallery-container {
            position: absolute; bottom: 0; left: 0; width: 100%; height: 100px;
            background: linear-gradient(to top, #000 10%, transparent);
            display: flex; align-items: center; overflow-x: auto; padding: 0 20px; z-index: 10; gap: 10px;
        }
        #gallery-container::-webkit-scrollbar { display: none; }
        .gallery-item {
            height: 60px; width: 60px; object-fit: cover;
            border-radius: 50%; /* ÂúÜÂΩ¢Â§¥ÂÉèÈ£éÊ†º */
            cursor: pointer; border: 2px solid #333;
            transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275); flex-shrink: 0; opacity: 0.6;
            filter: grayscale(100%);
        }
        .gallery-item:hover { transform: scale(1.2) translateY(-10px); opacity: 1; border-color: #fff; filter: grayscale(0%); }
        .gallery-item.selected { border-color: #d4af37; opacity: 1; box-shadow: 0 0 20px rgba(212, 175, 55, 0.6); transform: scale(1.2) translateY(-10px); filter: grayscale(0%); }
        
        #loading-text { color: #444; font-size: 12px; width: 100%; text-align: center; letter-spacing: 1px; }
        
        video { display: none; }
    </style>
</head>
<body>

    <div id="ui-panel">
        <div class="ui-label">SYSTEM STATE</div>
        <div id="status-text" class="status-text">INITIALIZING...</div>
        
        <div class="ui-label">CONTROLS</div>
        <div id="ctrl-hint-cam">
            <div class="hint">‚úä Êè°Êã≥: ËÅöÂêà (Tree)</div>
            <div class="hint">üñê Âº†ÂºÄ: ÁàÜÂèë (Gold)</div>
            <div class="hint">üëå ÊçèÂêà: Ê£ÄËßÜ (Photo)</div>
        </div>
        <div id="ctrl-hint-mouse" style="display:none">
            <div class="hint">‚ÜïÔ∏è Èº†Ê†á‰∏ä‰∏ã: ËÅöÊï£ÊéßÂà∂</div>
            <div class="hint">‚ÜîÔ∏è Èº†Ê†áÂ∑¶Âè≥: ËßÜËßíÊóãËΩ¨</div>
        </div>
    </div>

    <div id="canvas-container"></div>
    <video id="input_video"></video>

    <div id="gallery-container">
        <div id="loading-text">Ê≠£Âú®ÂêåÊ≠•‰∫ëÁ´ØÊï∞ÊçÆ...</div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <script>
        // --- Á¥†Êùê Base64 (ÈáëÂÖâÁ≤íÂ≠ê) ---
        const SPARK_TEX = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyJpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMC1jMDYwIDYxLjEzNDc3NywgMjAxMC8wMi8xMi0xNzozMjowMCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNSBNYWNpbnRvc2giIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6NDU4NEEwOUQwN0lDMTFFMzg2MzVEOEYxQjE0OEUwNTYiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6NDU4NEEwOUUwN0lDMTFFMzg2MzVEOEYxQjE0OEUwNTYiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDo0NTg0QTA5QjA3SUMxMUUzODYzNUQ4RjFCMTQ4RTA1NiIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo0NTg0QTA5QzA3SUMxMUUzODYzNUQ4RjFCMTQ4RTA1NiIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/Pp/b/CEAAABESURBVHja7M4xEQAwDAOxuVf6Z4wKbLgwF/B4Z2a9930eP378+PHjx48fP378+PHjx48fP378+PHjx48fP378+PHj/8YCDAD1ZQfR7B8r/QAAAABJRU5ErkJggg==";

        // ================= ÂÖ®Â±ÄÂèòÈáè =================
        let scene, camera, renderer, goldParticles, photoMesh;
        let photoParticleGroups = []; // Â≠òÊîæÁÖßÁâáÁ∫πÁêÜÁ≤íÂ≠ê
        let handOpenFactor = 0; // 0=Ê†ë(ËÅö), 1=ÁÇ∏(Êï£)
        let isMouseMode = false;
        let isPhotoMode = false;
        
        const GOLD_COUNT = 25000;
        const PHOTO_PARTICLES = 60; // ÊØèÂº†ÁÖßÁâáÁî±60‰∏™Á≤íÂ≠êÁªÑÊàê

        // ================= Three.js ÂàùÂßãÂåñ =================
        function initThree() {
            const container = document.getElementById('canvas-container');
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x050505, 0.0015); // ÊûÅÊ∑±ÁÅ∞Èõæ

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 3000);
            camera.position.z = 120;

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.outputEncoding = THREE.sRGBEncoding; 
            container.appendChild(renderer.domElement);

            // Âä†ËΩΩÂü∫Á°ÄÁ∫πÁêÜ
            const loader = new THREE.TextureLoader();
            const sparkTexture = loader.load(SPARK_TEX);
            
            // --- 1. ÈáëÁ≤âÂú£ËØûÊ†ë‰∏ª‰Ωì ---
            const goldGeo = new THREE.BufferGeometry();
            const goldPos = new Float32Array(GOLD_COUNT * 3);
            const goldTarget = new Float32Array(GOLD_COUNT * 3);
            const goldOffset = new Float32Array(GOLD_COUNT * 3);
            const goldColor = new Float32Array(GOLD_COUNT * 3);

            for(let i=0; i<GOLD_COUNT; i++) {
                const i3 = i*3;
                goldPos[i3]=0; goldPos[i3+1]=0; goldPos[i3+2]=0;
                
                // Ê†ëÂΩ¢ÁªìÊûÑ
                const h = Math.random(); 
                const angle = h * Math.PI * 20; // Ëû∫Êóã
                const r = (1-h) * 40 + Math.random()*3;
                goldTarget[i3] = Math.cos(angle)*r;
                goldTarget[i3+1] = (h-0.5)*110;
                goldTarget[i3+2] = Math.sin(angle)*r;

                // ÁàÜÁÇ∏ÂÅèÁßª
                goldOffset[i3] = (Math.random()-0.5)*2;
                goldOffset[i3+1] = (Math.random()-0.5)*2;
                goldOffset[i3+2] = (Math.random()-0.5)*2;

                // È¢úËâ≤Ê∑∑Êê≠ (Èáë/ÁôΩ/Á∫¢)
                const rnd = Math.random();
                const c = new THREE.Color();
                if(rnd>0.9) c.setHex(0xFFFFFF);
                else if(rnd>0.85) c.setHex(0xFF4500); // Ê©ôÁ∫¢
                else c.setHex(0xFFD700);
                
                goldColor[i3] = c.r; goldColor[i3+1] = c.g; goldColor[i3+2] = c.b;
            }
            goldGeo.setAttribute('position', new THREE.BufferAttribute(goldPos, 3));
            goldGeo.setAttribute('aTarget', new THREE.BufferAttribute(goldTarget, 3));
            goldGeo.setAttribute('aOffset', new THREE.BufferAttribute(goldOffset, 3));
            goldGeo.setAttribute('color', new THREE.BufferAttribute(goldColor, 3));

            const goldMat = new THREE.ShaderMaterial({
                uniforms: {
                    uTime: { value: 0 },
                    uFactor: { value: 0 },
                    uTex: { value: sparkTexture },
                    uIsPhoto: { value: 0 }
                },
                vertexShader: `
                    uniform float uTime;
                    uniform float uFactor; 
                    uniform float uIsPhoto;
                    attribute vec3 aTarget;
                    attribute vec3 aOffset;
                    attribute vec3 color;
                    varying vec3 vColor;
                    void main() {
                        vColor = color;
                        // Ê†ëÁöÑÊóãËΩ¨Âä®ÊÄÅ
                        vec3 posTree = aTarget;
                        float ang = uTime * 0.1 + aTarget.y * 0.005;
                        float ca = cos(ang); float sa = sin(ang);
                        posTree.x = aTarget.x * ca - aTarget.z * sa;
                        posTree.z = aTarget.x * sa + aTarget.z * ca;

                        // ÁàÜÁÇ∏Êï£ÂºÄ
                        vec3 posExp = aTarget + normalize(aOffset) * (120.0 + sin(uTime*2.0+aOffset.x)*20.0);
                        
                        // Ê∑∑ÂêàÔºöÂ¶ÇÊûúÂú®ÁúãÁÖßÁâáÔºåËÉåÊôØÁ®çÂæÆÊï£ÂºÄ‰∏ÄÁÇπ
                        float finalFactor = mix(uFactor, 1.0, uIsPhoto * 0.8);
                        vec3 finalPos = mix(posTree, posExp, finalFactor);
                        
                        vec4 mvPosition = modelViewMatrix * vec4(finalPos, 1.0);
                        gl_Position = projectionMatrix * mvPosition;
                        gl_PointSize = (3.5 * (1.0+finalFactor*0.8)) * (300.0 / -mvPosition.z);
                    }
                `,
                fragmentShader: `
                    uniform sampler2D uTex;
                    varying vec3 vColor;
                    void main() {
                        vec4 tex = texture2D(uTex, gl_PointCoord);
                        if(tex.a < 0.1) discard;
                        gl_FragColor = vec4(vColor * 1.5, tex.a); // ‰∫ÆÂ∫¶Â¢ûÂº∫
                    }
                `,
                transparent: true, depthWrite: false, blending: THREE.AdditiveBlending
            });
            goldParticles = new THREE.Points(goldGeo, goldMat);
            scene.add(goldParticles);

            // --- 2. ÁÖßÁâáÂÖ®ÊÅØÂ§ßÂõæ (ÁÇπÂáªÂêéÊòæÁ§∫) ---
            photoMesh = new THREE.Mesh(
                new THREE.PlaneGeometry(1,1),
                new THREE.MeshBasicMaterial({ transparent: true, opacity: 0, side: THREE.DoubleSide })
            );
            // ÈáëËâ≤ÂÖâÊ°Ü
            const borderMat = new THREE.MeshBasicMaterial({ color: 0xFFD700, side: THREE.BackSide, transparent: true, opacity: 0 });
            const borderMesh = new THREE.Mesh(new THREE.PlaneGeometry(1.02, 1.02), borderMat);
            borderMesh.position.z = -0.2;
            photoMesh.add(borderMesh);
            photoMesh.userData = { border: borderMesh }; // ÂºïÁî®‰øùÂ≠ò
            scene.add(photoMesh);

            window.addEventListener('resize', onResize);
        }

        function onResize() {
            camera.aspect = window.innerWidth/window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // ================= ‰∫§‰∫íÈÄªËæë =================
        async function loadGallery() {
            const container = document.getElementById('gallery-container');
            const status = document.getElementById('loading-text');
            const texLoader = new THREE.TextureLoader();
            texLoader.crossOrigin = "Anonymous";

            try {
                // ËØ∑Ê±Ç Node.js Ëé∑ÂèñÂõæÁâáÂàóË°® (‰ºöËá™Âä®Ëµ∞ static ÂüüÂêç)
                const res = await fetch('/api/images');
                const images = await res.json();
                
                container.innerHTML = '';
                if(images.length === 0) { status.innerText = "Áõ∏ÂÜå‰∏∫Á©∫"; return; }

                const loadedTextures = [];

                // ÂºÇÊ≠•Âä†ËΩΩÁ∫πÁêÜ
                const promises = images.map((imgData, idx) => {
                    return new Promise(resolve => {
                        const url = imgData.url + "?t=" + Date.now(); // Èò≤ÁºìÂ≠ò
                        
                        // DOM
                        const el = document.createElement('img');
                        el.src = url; el.className = 'gallery-item';
                        el.onclick = () => {
                            document.querySelectorAll('.gallery-item').forEach(e=>e.classList.remove('selected'));
                            el.classList.add('selected');
                            showBigPhoto(url);
                        };
                        container.appendChild(el);

                        // Three.js Texture
                        texLoader.load(url, (tex) => {
                            loadedTextures.push(tex);
                            resolve();
                        });
                    });
                });

                await Promise.all(promises);
                status.remove();
                
                // --- 3. Ê†∏ÂøÉÔºöÊääÁÖßÁâáÂÅöÊàêÁ≤íÂ≠êÊùêË¥®Ë¥¥ÂõæÊîæËøõÂéª ---
                createPhotoParticles(loadedTextures);

            } catch(e) {
                console.error(e);
                status.innerText = "Êï∞ÊçÆËøûÊé•‰∏≠Êñ≠";
            }
        }

        function createPhotoParticles(textures) {
            // ÁÖßÁâáÁ≤íÂ≠ê ShaderÔºöÈááÊ†∑‰º†ÂÖ•ÁöÑ uTex
            const matTemplate = new THREE.ShaderMaterial({
                uniforms: { uTime: { value: 0 }, uFactor: { value: 0 }, uIsPhoto: { value: 0 }, uTex: { value: null } },
                vertexShader: `
                    uniform float uTime;
                    uniform float uFactor;
                    uniform float uIsPhoto;
                    attribute vec3 aBasePos;
                    attribute float aSpeed;
                    void main() {
                        // Âõ¥ÁªïÊ†ëÊÖ¢ÈÄüÊóãËΩ¨
                        float ang = uTime * 0.05 * aSpeed + aBasePos.y * 0.02;
                        vec3 pos;
                        pos.x = aBasePos.x * cos(ang) - aBasePos.z * sin(ang);
                        pos.z = aBasePos.x * sin(ang) + aBasePos.z * cos(ang);
                        pos.y = aBasePos.y + sin(uTime + aBasePos.x * 0.1) * 5.0; // ‰∏ä‰∏ãÊµÆÂä®

                        // ‰∫§‰∫íÊ∑∑Âêà
                        float finalFactor = mix(uFactor, 1.0, uIsPhoto);
                        vec3 finalPos = pos * (0.8 + finalFactor * 2.0); // Âº†ÂºÄÊó∂È£ûËøú

                        vec4 mvPosition = modelViewMatrix * vec4(finalPos, 1.0);
                        gl_Position = projectionMatrix * mvPosition;
                        
                        // ÁÖßÁâáÁ≤íÂ≠êËæÉÂ§ß
                        gl_PointSize = 20.0 * (300.0 / -mvPosition.z);
                    }
                `,
                fragmentShader: `
                    uniform sampler2D uTex;
                    void main() {
                        // ÈááÊ†∑ÁÖßÁâá
                        vec4 color = texture2D(uTex, gl_PointCoord);
                        // ÂúÜÂΩ¢Ë£ÅÂàá
                        vec2 c = gl_PointCoord - 0.5;
                        if(length(c) > 0.5) discard;
                        // Âä†‰∏ÄÁÇπÈáëËæπ
                        float border = smoothstep(0.45, 0.5, length(c));
                        vec3 finalC = mix(color.rgb, vec3(1.0, 0.8, 0.0), border);
                        gl_FragColor = vec4(finalC, 1.0);
                    }
                `,
                transparent: true, depthWrite: false
            });

            // ‰∏∫ÊØèÂº†Á∫πÁêÜÂàõÂª∫‰∏ÄÁªÑÊºÇÊµÆÁ≤íÂ≠ê
            textures.forEach(tex => {
                const geo = new THREE.BufferGeometry();
                const pos = new Float32Array(PHOTO_PARTICLES * 3);
                const base = new Float32Array(PHOTO_PARTICLES * 3);
                const spd = new Float32Array(PHOTO_PARTICLES);

                for(let i=0; i<PHOTO_PARTICLES; i++) {
                    pos[i*3]=0; pos[i*3+1]=0; pos[i*3+2]=0;
                    // ÈöèÊú∫ÂàÜÂ∏ÉÂú®Ê†ëÂë®Âõ¥
                    const r = 25 + Math.random()*50;
                    const theta = Math.random()*Math.PI*2;
                    const y = (Math.random()-0.5)*130;
                    base[i*3] = Math.cos(theta)*r;
                    base[i*3+1] = y;
                    base[i*3+2] = Math.sin(theta)*r;
                    spd[i] = 0.5 + Math.random();
                }
                geo.setAttribute('position', new THREE.BufferAttribute(pos, 3));
                geo.setAttribute('aBasePos', new THREE.BufferAttribute(base, 3));
                geo.setAttribute('aSpeed', new THREE.BufferAttribute(spd, 1));

                const mat = matTemplate.clone();
                mat.uniforms.uTex.value = tex;
                
                const sys = new THREE.Points(geo, mat);
                scene.add(sys);
                photoParticleGroups.push(sys);
            });
        }

        function showBigPhoto(url) {
            isPhotoMode = true;
            const loader = new THREE.TextureLoader();
            loader.crossOrigin = "Anonymous";
            loader.load(url, (tex) => {
                const aspect = tex.image.width / tex.image.height;
                photoMesh.geometry.dispose();
                const h = 50; 
                photoMesh.geometry = new THREE.PlaneGeometry(h*aspect, h);
                photoMesh.userData.border.geometry.dispose();
                photoMesh.userData.border.geometry = new THREE.PlaneGeometry(h*aspect+1, h+1);
                
                photoMesh.material.map = tex;
                photoMesh.material.needsUpdate = true;
            });
        }

        // ================= Ê†∏ÂøÉÔºöÈùôÈªòÂàáÊç¢Ê®°Âºè =================
        function switchToMouseMode() {
            if(isMouseMode) return;
            isMouseMode = true;
            document.getElementById('status-text').innerText = "MOUSE INTERACTION";
            document.getElementById('status-text').style.color = "#00ffaa";
            document.getElementById('ctrl-hint-cam').style.display = 'none';
            document.getElementById('ctrl-hint-mouse').style.display = 'block';
        }

        function initMediaPipe() {
            const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
            hands.setOptions({maxNumHands: 1, modelComplexity: 0});
            
            hands.onResults(results => {
                // Â¶ÇÊûúÊúâÊâãÂäøÊï∞ÊçÆÔºåÂàáÂõûÊëÑÂÉèÂ§¥Ê®°ÂºèÈÄªËæë
                if(results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                    const lm = results.multiHandLandmarks[0];
                    const d = Math.hypot(lm[8].x - lm[0].x, lm[8].y - lm[0].y);
                    let target = (d - 0.2) * 3.0; 
                    handOpenFactor += (Math.max(0, Math.min(1, target)) - handOpenFactor) * 0.1;
                    
                    const status = document.getElementById('status-text');
                    if(handOpenFactor < 0.35) status.innerText = "STATE: TREE (FIST)";
                    else status.innerText = "STATE: BURST (OPEN)";
                    
                    const pinch = Math.hypot(lm[4].x-lm[8].x, lm[4].y-lm[8].y);
                    if(pinch < 0.05) status.innerText = "STATE: PHOTO VIEW";
                } else if(!isMouseMode) {
                    // ÊëÑÂÉèÂ§¥ÂºÄÂêØ‰ΩÜÊ≤°‰∫∫Êâã
                    handOpenFactor += (0 - handOpenFactor) * 0.05;
                    document.getElementById('status-text').innerText = "WAITING FOR HAND...";
                }
            });

            // ‚ö°Ô∏è Ê†∏ÂøÉ‰øÆÊîπÔºöÈùôÈªòÈôçÁ∫ßÈÄªËæë
            const cam = new Camera(document.getElementById('input_video'), {
                onFrame: async () => { await hands.send({image: document.getElementById('input_video')}); },
                width: 320, height: 240
            });

            // 3ÁßíËøû‰∏ç‰∏äÂ∞±ÂàáÈº†Ê†á
            const failTimer = setTimeout(() => {
                console.log("Camera init timeout, switching to mouse.");
                switchToMouseMode();
            }, 3000);

            cam.start()
            .then(() => {
                clearTimeout(failTimer);
                document.getElementById('status-text').innerText = "CAMERA ACTIVE";
            })
            .catch(err => {
                clearTimeout(failTimer);
                console.log("Camera failed/denied, switching to mouse.");
                switchToMouseMode(); // Â§±Ë¥•Áõ¥Êé•ÂàáÔºå‰∏çÂºπÁ™ó
            });
        }

        // Èº†Ê†áÂÖºÂÆπ
        document.addEventListener('mousemove', (e) => {
            if(isMouseMode) {
                // Èº†Ê†áË∂äÂæÄ‰∏ã(YÂ§ß)ÔºåfactorË∂äÂ∞è(0)ÔºåËÅöÊã¢
                handOpenFactor = 1.0 - (e.clientY / window.innerHeight);
                if(goldParticles) goldParticles.rotation.y = (e.clientX/window.innerWidth - 0.5) * 1.0;
            }
        });

        // Âä®ÁîªÂæ™ÁéØ
        function animate() {
            requestAnimationFrame(animate);
            const time = Date.now() * 0.001;

            if(goldParticles) {
                goldParticles.material.uniforms.uTime.value = time;
                goldParticles.material.uniforms.uFactor.value = handOpenFactor;
                // Âπ≥ÊªëÂàáÊç¢
                goldParticles.material.uniforms.uIsPhoto.value += ((isPhotoMode?1:0) - goldParticles.material.uniforms.uIsPhoto.value)*0.1;
                
                // ÁÖßÁâáÁ≤íÂ≠êÂêåÊ≠•
                photoParticleGroups.forEach(sys => {
                    sys.material.uniforms.uTime.value = time;
                    sys.material.uniforms.uFactor.value = handOpenFactor;
                    sys.material.uniforms.uIsPhoto.value = goldParticles.material.uniforms.uIsPhoto.value;
                });
            }

            if(photoMesh) {
                const targetOp = isPhotoMode ? 1.0 : 0.0;
                photoMesh.material.opacity += (targetOp - photoMesh.material.opacity) * 0.1;
                photoMesh.userData.border.material.opacity = photoMesh.material.opacity * 0.8;
                if(isPhotoMode) {
                    photoMesh.position.y = Math.sin(time)*2.0; 
                    photoMesh.rotation.y = Math.sin(time*0.5)*0.1;
                }
            }

            renderer.render(scene, camera);
        }

        initThree();
        initMediaPipe();
        loadGallery();

    </script>
</body>
</html>