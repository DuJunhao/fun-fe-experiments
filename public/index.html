<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å¥¢åå›å¿†åœ£è¯æ ‘ AR</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: sans-serif; user-select: none; }
        #canvas-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; }

        /* UI é¢æ¿ */
        #ui-panel {
            position: absolute; top: 20px; left: 20px; width: 180px;
            background: rgba(10, 10, 10, 0.7); backdrop-filter: blur(10px);
            padding: 15px; border-radius: 10px; color: #d4af37; z-index: 10;
            border: 1px solid rgba(212, 175, 55, 0.4);
            box-shadow: 0 0 25px rgba(212, 175, 55, 0.2);
        }
        .ui-label { font-size: 10px; letter-spacing: 2px; color: #aaa; margin-bottom: 8px; font-weight: bold; }
        .status-text { font-size: 14px; color: #fff; text-shadow: 0 0 8px gold; font-weight: bold;}

        /* åº•éƒ¨ç…§ç‰‡æ  */
        #gallery-container {
            position: absolute; bottom: 0; left: 0; width: 100%; height: 120px;
            background: linear-gradient(to top, #000 20%, transparent);
            display: flex; align-items: center; overflow-x: auto; padding: 0 25px; z-index: 10; gap: 15px;
        }
        /* éšè—æ»šåŠ¨æ¡ */
        #gallery-container::-webkit-scrollbar { display: none; }
        .gallery-item {
            height: 75px; width: 75px; object-fit: cover;
            border-radius: 6px; cursor: pointer; border: 2px solid rgba(212, 175, 55, 0.3);
            transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275); flex-shrink: 0; opacity: 0.7;
        }
        .gallery-item:hover { transform: scale(1.15) translateY(-5px); opacity: 1; border-color: gold; }
        .gallery-item.selected { border-color: gold; opacity: 1; box-shadow: 0 0 20px gold; transform: scale(1.15) translateY(-5px); }
        
        #loading-text { color: #d4af37; font-size: 14px; width: 100%; text-align: center; letter-spacing: 1px;}
        
        video { display: none; }
    </style>
</head>
<body>

    <div id="ui-panel">
        <div class="ui-label">SYSTEM STATUS</div>
        <div id="status-text" class="status-text">INITIALIZING...</div>
        <div class="ui-label" style="margin-top:20px">GESTURE CONTROL</div>
        <div style="font-size:12px; color:#ccc; margin-bottom:4px;">âœŠ æ¡æ‹³: èšåˆå›å¿†æ ‘</div>
        <div style="font-size:12px; color:#ccc; margin-bottom:4px;">ğŸ– å¼ å¼€: é‡‘è‰²çˆ†å‘</div>
        <div style="font-size:12px; color:#ccc;">ğŸ‘Œ æåˆ: æ£€è§†ç…§ç‰‡</div>
    </div>

    <div id="canvas-container"></div>
    <video id="input_video"></video>

    <div id="gallery-container">
        <div id="loading-text">æ­£åœ¨è¿æ¥äº‘ç«¯å›å¿†åº“...</div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <script>
        // --- ç´ æ Base64 (é‡‘å…‰ç‚¹) ---
        const SPARK_TEX = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyJpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMC1jMDYwIDYxLjEzNDc3NywgMjAxMC8wMi8xMi0xNzozMjowMCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNSBNYWNpbnRvc2giIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6NDU4NEEwOUQwN0lDMTFFMzg2MzVEOEYxQjE0OEUwNTYiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6NDU4NEEwOUUwN0lDMTFFMzg2MzVEOEYxQjE0OEUwNTYiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDo0NTg0QTA5QjA3SUMxMUUzODYzNUQ4RjFCMTQ4RTA1NiIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo0NTg0QTA5QzA3SUMxMUUzODYzNUQ4RjFCMTQ4RTA1NiIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/Pp/b/CEAAABESURBVHja7M4xEQAwDAOxuVf6Z4wKbLgwF/B4Z2a9930eP378+PHjx48fP378+PHjx48fP378+PHjx48fP378+PHj/8YCDAD1ZQfR7B8r/QAAAABJRU5ErkJggg==";

        // ================= å…¨å±€å˜é‡ =================
        let scene, camera, renderer, goldParticles, photoMesh;
        // å­˜æ”¾æ‰€æœ‰ç…§ç‰‡ç²’å­ç³»ç»Ÿçš„æ•°ç»„
        let photoParticleGroups = []; 
        let handOpenFactor = 0; // 0=æ ‘, 1=çˆ†ç‚¸
        let isMouseMode = false;
        let isPhotoMode = false;
        
        const GOLD_COUNT = 30000;
        // æ¯å¼ ç…§ç‰‡ç”Ÿæˆå¤šå°‘ä¸ªæ¼‚æµ®ç²’å­
        const PARTICLES_PER_PHOTO = 40; 

        // ================= Three.js åˆå§‹åŒ– =================
        function initThree() {
            const container = document.getElementById('canvas-container');
            scene = new THREE.Scene();
            // ç¨å¾®å¸¦ç‚¹é‡‘è‰²è°ƒçš„è¿·é›¾
            scene.fog = new THREE.FogExp2(0x1a1a00, 0.0012); 

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 3000);
            camera.position.z = 120;

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.outputEncoding = THREE.sRGBEncoding;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.2;
            container.appendChild(renderer.domElement);

            // åŠ è½½é‡‘å…‰çº¹ç†
            const loader = new THREE.TextureLoader();
            const sparkTexture = loader.load(SPARK_TEX);
            
            // --- ç³»ç»Ÿ1: é‡‘ç²‰ä¸»æ ‘ä½“ ---
            const goldGeo = new THREE.BufferGeometry();
            const goldPos = new Float32Array(GOLD_COUNT * 3);
            const goldTarget = new Float32Array(GOLD_COUNT * 3);
            const goldOffset = new Float32Array(GOLD_COUNT * 3);
            const goldColor = new Float32Array(GOLD_COUNT * 3);

            for(let i=0; i<GOLD_COUNT; i++) {
                const i3 = i*3;
                goldPos[i3]=0; goldPos[i3+1]=0; goldPos[i3+2]=0;
                
                // æ ‘å½¢ç›®æ ‡ (æ›´ç´§å¯†çš„èºæ—‹åœ†é”¥)
                const h = Math.random(); 
                const angle = h * Math.PI * 22; 
                const r = (1-h) * 38 + Math.random()*3;
                goldTarget[i3] = Math.cos(angle)*r;
                goldTarget[i3+1] = (h-0.5)*100;
                goldTarget[i3+2] = Math.sin(angle)*r;

                // çˆ†ç‚¸åç§»
                goldOffset[i3] = (Math.random()-0.5)*2;
                goldOffset[i3+1] = (Math.random()-0.5)*2;
                goldOffset[i3+2] = (Math.random()-0.5)*2;

                // é¢œè‰²ï¼šå¥¢åé‡‘è°ƒè‰²æ¿
                const colorType = Math.random();
                const col = new THREE.Color();
                if(colorType > 0.95) col.setHex(0xFFFFFF); // é’»çŸ³ç™½é—ª
                else if(colorType > 0.85) col.setHex(0xFFEDA0); // æµ…é‡‘
                else col.setHex(0xFFD700); // çº¯é‡‘
                
                goldColor[i3] = col.r; goldColor[i3+1] = col.g; goldColor[i3+2] = col.b;
            }
            goldGeo.setAttribute('position', new THREE.BufferAttribute(goldPos, 3));
            goldGeo.setAttribute('aTarget', new THREE.BufferAttribute(goldTarget, 3));
            goldGeo.setAttribute('aOffset', new THREE.BufferAttribute(goldOffset, 3));
            goldGeo.setAttribute('color', new THREE.BufferAttribute(goldColor, 3));

            const goldMat = new THREE.ShaderMaterial({
                uniforms: {
                    uTime: { value: 0 },
                    uFactor: { value: 0 },
                    uTex: { value: sparkTexture },
                    uIsPhoto: { value: 0 }
                },
                // (Vertex Shader ä¿æŒä¸å˜ï¼Œè´Ÿè´£å½¢æ€åˆ‡æ¢)
                vertexShader: `
                    uniform float uTime;
                    uniform float uFactor; 
                    uniform float uIsPhoto;
                    attribute vec3 aTarget;
                    attribute vec3 aOffset;
                    attribute vec3 color;
                    varying vec3 vColor;
                    void main() {
                        vColor = color;
                        vec3 posTree = aTarget;
                        float angle = uTime * 0.15 + aTarget.y * 0.01;
                        float ca = cos(angle); float sa = sin(angle);
                        posTree.x = aTarget.x * ca - aTarget.z * sa;
                        posTree.z = aTarget.x * sa + aTarget.z * ca;

                        vec3 posExp = aTarget + normalize(aOffset) * (100.0 + sin(uTime*2.5+aOffset.x)*15.0);
                        
                        float finalFactor = mix(uFactor, 1.0, uIsPhoto * 0.95);
                        vec3 finalPos = mix(posTree, posExp, finalFactor);
                        
                        vec4 mvPosition = modelViewMatrix * vec4(finalPos, 1.0);
                        gl_Position = projectionMatrix * mvPosition;
                        gl_PointSize = (3.5 * (1.0+finalFactor*0.5)) * (300.0 / -mvPosition.z);
                    }
                `,
                fragmentShader: `
                    uniform sampler2D uTex;
                    varying vec3 vColor;
                    void main() {
                        vec4 tex = texture2D(uTex, gl_PointCoord);
                        if(tex.a < 0.1) discard;
                        // å¢å¼ºäº®åº¦ï¼Œåˆ¶é€ è¾‰å…‰æ„Ÿ
                        gl_FragColor = vec4(vColor * 1.5, tex.a);
                    }
                `,
                transparent: true,
                depthWrite: false,
                blending: THREE.AdditiveBlending
            });
            goldParticles = new THREE.Points(goldGeo, goldMat);
            scene.add(goldParticles);

            // --- ç…§ç‰‡å±•ç¤ºå¹³é¢ (ç‚¹å‡»åæ˜¾ç¤ºçš„å¤§å›¾) ---
            photoMesh = new THREE.Mesh(
                new THREE.PlaneGeometry(1,1),
                new THREE.MeshBasicMaterial({ transparent: true, opacity: 0, side: THREE.DoubleSide })
            );
            // ç»™å¤§å›¾åŠ ä¸€ä¸ªé‡‘è‰²è¾¹æ¡†å…‰æ™•
            const outlineMat = new THREE.MeshBasicMaterial({ color: 0xFFD700, side: THREE.BackSide, blending: THREE.AdditiveBlending, transparent: true, opacity: 0.5 });
            const outlineMesh = new THREE.Mesh(new THREE.PlaneGeometry(1.05, 1.05), outlineMat);
            outlineMesh.position.z = -0.1;
            photoMesh.add(outlineMesh);
            scene.add(photoMesh);

            window.addEventListener('resize', onResize);
        }

        function onResize() {
            camera.aspect = window.innerWidth/window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // ================= äº¤äº’é€»è¾‘ä¸ç…§ç‰‡åŠ è½½ =================
        // 1. åŠ è½½ç”»å»Š å¹¶ åˆ›å»ºç…§ç‰‡ç²’å­
        async function loadGallery() {
            const container = document.getElementById('gallery-container');
            const status = document.getElementById('loading-text');
            const textureLoader = new THREE.TextureLoader();
            textureLoader.crossOrigin = "Anonymous";

            try {
                const res = await fetch('/api/images');
                const images = await res.json();
                
                container.innerHTML = '';
                if(images.length === 0) { status.innerText = "Bucketä¸ºç©º"; return; }

                // ç”¨äºå­˜å‚¨æ‰€æœ‰åŠ è½½å¥½çš„çº¹ç†
                const loadedTextures = [];

                // å¹¶è¡ŒåŠ è½½æ‰€æœ‰å›¾ç‰‡çº¹ç†ï¼Œå¹¶åœ¨åº•éƒ¨UIæ˜¾ç¤º
                const loadPromises = images.map((imgData, idx) => {
                    return new Promise((resolve) => {
                        const timestampedUrl = imgData.url + "?t=" + Date.now();
                        
                        // A. åˆ›å»º UI ç¼©ç•¥å›¾
                        const el = document.createElement('img');
                        el.src = timestampedUrl;
                        el.className = 'gallery-item';
                        el.onclick = () => {
                            document.querySelectorAll('.gallery-item').forEach(e=>e.classList.remove('selected'));
                            el.classList.add('selected');
                            showPhoto(imgData.url);
                        };
                        if(idx===0) el.click();
                        container.appendChild(el);

                        // B. åŠ è½½ Three.js çº¹ç†
                        textureLoader.load(timestampedUrl, (tex) => {
                            // è®¾ç½®çº¹ç†å‚æ•°ä»¥é€‚åº”ç²’å­
                            tex.minFilter = THREE.LinearMipMapLinearFilter;
                            tex.magFilter = THREE.LinearFilter;
                            loadedTextures.push(tex);
                            resolve();
                        });
                    });
                });

                // ç­‰å¾…æ‰€æœ‰çº¹ç†åŠ è½½å®Œæ¯•
                await Promise.all(loadPromises);
                status.remove(); // ç§»é™¤åŠ è½½æç¤º

                // C. æ ¸å¿ƒï¼šä¸ºæ¯å¼ ç…§ç‰‡åˆ›å»ºæ¼‚æµ®ç²’å­ç³»ç»Ÿ
                createPhotoParticleSystems(loadedTextures);

            } catch(e) {
                console.error(e);
                status.innerText = "è¿æ¥åç«¯å¤±è´¥: /api/images";
            }
        }

        // åˆ›å»ºç…§ç‰‡ç²’å­ç³»ç»Ÿçš„å‡½æ•°
        function createPhotoParticleSystems(textures) {
            // ç…§ç‰‡ç²’å­çš„ Shader (å¤ç”¨é€»è¾‘ï¼Œä½†é‡‡æ ·çº¹ç†)
            const photoMatTemplate = new THREE.ShaderMaterial({
                uniforms: { uTime: { value: 0 }, uFactor: { value: 0 }, uIsPhoto: { value: 0 }, uTex: { value: null } },
                vertexShader: `
                    uniform float uTime;
                    uniform float uFactor;
                    uniform float uIsPhoto;
                    attribute vec3 aBasePos;
                    attribute float aSpeed;
                    void main() {
                        // å›´ç»•ä¸­å¿ƒç¼“æ…¢æ—‹è½¬æ¼‚æµ®
                        float angle = uTime * aSpeed * 0.05 + aBasePos.y * 0.02;
                        vec3 pos;
                        pos.x = aBasePos.x * cos(angle) - aBasePos.z * sin(angle);
                        pos.z = aBasePos.x * sin(angle) + aBasePos.z * cos(angle);
                        // ä¸Šä¸‹æµ®åŠ¨
                        pos.y = aBasePos.y + sin(uTime * aSpeed + aBasePos.x)*8.0;

                        // æ¡æ‹³æ—¶å¸é™„ï¼Œå¼ å¼€æ—¶é£è¿œ
                        float finalFactor = mix(uFactor, 1.0, uIsPhoto);
                        vec3 finalPos = pos * (0.6 + finalFactor * 2.0);

                        vec4 mvPosition = modelViewMatrix * vec4(finalPos, 1.0);
                        gl_Position = projectionMatrix * mvPosition;
                        // ç…§ç‰‡ç²’å­è¦å¤§ä¸€äº›
                        gl_PointSize = 25.0 * (300.0 / -mvPosition.z);
                    }
                `,
                fragmentShader: `
                    uniform sampler2D uTex;
                    void main() {
                        // é‡‡æ ·ç…§ç‰‡çº¹ç†
                        vec4 texColor = texture2D(uTex, gl_PointCoord);
                        // ç®€å•çš„åœ†å½¢è£åˆ‡ (å¦‚æœå–œæ¬¢æ–¹å½¢å¯ä»¥å»æ‰è¿™ä¸¤è¡Œ)
                        vec2 coord = gl_PointCoord - vec2(0.5);
                        if(length(coord) > 0.5) discard;
                        
                        // åŠ ä¸€ç‚¹é‡‘è‰²è¾¹æ¡†å…‰æ™•
                        float dist = length(coord);
                        float rim = smoothstep(0.45, 0.5, dist);
                        vec3 finalColor = mix(texColor.rgb, vec3(1.0, 0.84, 0.0), rim * 0.8);

                        gl_FragColor = vec4(finalColor, texColor.a);
                    }
                `,
                transparent: true,
                depthWrite: false
                // ä¸ç”¨ AdditiveBlendingï¼Œå› ä¸ºè¦çœ‹æ¸…ç…§ç‰‡å†…å®¹
            });

            // ä¸ºæ¯ä¸€å¼ çº¹ç†åˆ›å»ºä¸€ä¸ªç²’å­ç³»ç»Ÿ
            textures.forEach(tex => {
                const geo = new THREE.BufferGeometry();
                const pos = new Float32Array(PARTICLES_PER_PHOTO * 3);
                const basePos = new Float32Array(PARTICLES_PER_PHOTO * 3);
                const speed = new Float32Array(PARTICLES_PER_PHOTO);

                for(let i=0; i<PARTICLES_PER_PHOTO; i++) {
                    pos[i*3]=0; pos[i*3+1]=0; pos[i*3+2]=0;
                    // éšæœºåˆ†å¸ƒåœ¨æ ‘å‘¨å›´è¾ƒè¿œçš„åœ°æ–¹
                    const r = 30 + Math.random()*60;
                    const theta = Math.random()*Math.PI*2;
                    const y = (Math.random()-0.5)*120;
                    basePos[i*3] = Math.cos(theta)*r;
                    basePos[i*3+1] = y;
                    basePos[i*3+2] = Math.sin(theta)*r;
                    speed[i] = 0.5 + Math.random();
                }
                geo.setAttribute('position', new THREE.BufferAttribute(pos, 3));
                geo.setAttribute('aBasePos', new THREE.BufferAttribute(basePos, 3));
                geo.setAttribute('aSpeed', new THREE.BufferAttribute(speed, 1));

                // å…‹éš†æè´¨æ¨¡æ¿å¹¶ç»‘å®šå½“å‰çº¹ç†
                const mat = photoMatTemplate.clone();
                mat.uniforms.uTex.value = tex;

                const points = new THREE.Points(geo, mat);
                scene.add(points);
                photoParticleGroups.push(points);
            });
        }

        // 2. æ˜¾ç¤ºå¤§å›¾
        function showPhoto(url) {
            isPhotoMode = true;
            const loader = new THREE.TextureLoader();
            loader.crossOrigin = "Anonymous";
            loader.load(url + "?t=" + Date.now(), (tex) => {
                const aspect = tex.image.width / tex.image.height;
                photoMesh.geometry.dispose();
                const h = 45; // å¤§å›¾é«˜åº¦
                photoMesh.geometry = new THREE.PlaneGeometry(h*aspect, h);
                photoMesh.material.map = tex;
                photoMesh.material.needsUpdate = true;
                // æ›´æ–°è¾¹æ¡†å°ºå¯¸
                photoMesh.children[0].geometry.dispose();
                photoMesh.children[0].geometry = new THREE.PlaneGeometry(h*aspect+2, h+2);
            });
        }

        // 3. MediaPipe æ‰‹åŠ¿
        function initMediaPipe() {
            const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
            hands.setOptions({maxNumHands: 1, modelComplexity: 0, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5});
            
            hands.onResults(results => {
                if(results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                    isMouseMode = false;
                    const lm = results.multiHandLandmarks[0];
                    const d = Math.hypot(lm[8].x - lm[0].x, lm[8].y - lm[0].y); 
                    let target = (d - 0.2) * 3.0; 
                    handOpenFactor += (Math.max(0, Math.min(1, target)) - handOpenFactor) * 0.1;
                    
                    const status = document.getElementById('status-text');
                    if(handOpenFactor < 0.35) status.innerText = "çŠ¶æ€: èšåˆå›å¿† (æ¡æ‹³)";
                    else status.innerText = "çŠ¶æ€: é‡‘è‰²çˆ†å‘ (å¼ æ‰‹)";
                    
                    const pinch = Math.hypot(lm[4].x-lm[8].x, lm[4].y-lm[8].y);
                    if(pinch < 0.05) status.innerText = "çŠ¶æ€: æ£€è§†ç…§ç‰‡ (æåˆ)";
                } else if(!isMouseMode) {
                    handOpenFactor += (0 - handOpenFactor) * 0.05;
                    document.getElementById('status-text').innerText = "ç­‰å¾…æ‰‹åŠ¿...";
                }
            });

            const cam = new Camera(document.getElementById('input_video'), {
                onFrame: async () => { await hands.send({image: document.getElementById('input_video')}); },
                width: 320, height: 240
            });
            cam.start();
        }

        // 4. åŠ¨ç”»å¾ªç¯
        function animate() {
            requestAnimationFrame(animate);
            const time = Date.now() * 0.001;

            // æ›´æ–°é‡‘ç²‰ç²’å­
            if(goldParticles) {
                goldParticles.material.uniforms.uTime.value = time;
                goldParticles.material.uniforms.uFactor.value = handOpenFactor;
                goldParticles.material.uniforms.uIsPhoto.value += ((isPhotoMode?1:0) - goldParticles.material.uniforms.uIsPhoto.value)*0.1;
            }

            // æ›´æ–°æ‰€æœ‰ç…§ç‰‡ç²’å­ç³»ç»Ÿ
            photoParticleGroups.forEach(sys => {
                sys.material.uniforms.uTime.value = time;
                sys.material.uniforms.uFactor.value = handOpenFactor;
                sys.material.uniforms.uIsPhoto.value = goldParticles.material.uniforms.uIsPhoto.value;
            });

            // æ›´æ–°å¤§å›¾å±•ç¤º
            if(photoMesh) {
                const targetOp = isPhotoMode ? 1.0 : 0.0;
                photoMesh.material.opacity += (targetOp - photoMesh.material.opacity) * 0.1;
                photoMesh.children[0].material.opacity = photoMesh.material.opacity * 0.6; // è¾¹æ¡†é€æ˜åº¦
                if(isPhotoMode) {
                    photoMesh.position.y = Math.sin(time*1.5)*1.5; // æ‚¬æµ®
                    photoMesh.rotation.y = Math.sin(time*0.8)*0.08; // å¾®å°æ‘†åŠ¨
                }
            }

            renderer.render(scene, camera);
        }

        // å¯åŠ¨
        initThree();
        initMediaPipe();
        loadGallery();

    </script>
</body>
</html>