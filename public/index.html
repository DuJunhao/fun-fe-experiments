<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Three.js å®æ—¶æ‰‹åŠ¿äº¤äº’ç²’å­ç³»ç»Ÿ</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            font-family: 'Helvetica Neue', Arial, sans-serif;
        }
        #canvas-container {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            z-index: 1;
        }
        /* ç°ä»£ UI é¢æ¿æ ·å¼ */
        #ui-panel {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(20, 20, 20, 0.8);
            backdrop-filter: blur(10px);
            padding: 20px;
            border-radius: 12px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.3);
            color: #fff;
            z-index: 10;
            display: flex;
            flex-direction: column;
            gap: 15px;
            width: 220px;
            border: 1px solid rgba(255,255,255,0.1);
        }
        .ui-group { display: flex; flex-direction: column; gap: 8px; }
        label { font-size: 12px; color: #aaa; letter-spacing: 1px; text-transform: uppercase;}
        /* æŒ‰é’®æ ·å¼ */
        .shape-btn {
            background: rgba(255,255,255,0.1);
            border: none;
            color: #fff;
            padding: 10px;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: left;
            font-size: 14px;
        }
        .shape-btn:hover { background: rgba(255,255,255,0.2); }
        .shape-btn.active { background: #007bff; box-shadow: 0 0 15px rgba(0, 123, 255, 0.5); }
        /* é¢œè‰²é€‰æ‹©å™¨ */
        input[type="color"] {
            width: 100%; height: 40px; border: none; border-radius: 6px; cursor: pointer; background: none;
        }
        /* å…¨å±æŒ‰é’® */
        #fullscreen-btn {
            position: absolute; bottom: 20px; right: 20px;
            background: rgba(20,20,20,0.8); color: #fff;
            border: 1px solid rgba(255,255,255,0.1); padding: 10px 15px;
            border-radius: 8px; cursor: pointer; z-index: 10;
        }
        /* ç”¨äºéšè— MediaPipe çš„è§†é¢‘æµ */
        .input_video { display: none; }
        #loading {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: #007bff; font-size: 24px; z-index: 20; pointer-events: none;
        }
    </style>
</head>
<body>
    <div id="loading">æ­£åœ¨å¯åŠ¨æ‘„åƒå¤´å’Œ AI æ¨¡å‹...</div>
    <div id="canvas-container"></div>

    <div id="ui-panel">
        <div class="ui-group">
            <label>ç²’å­å½¢çŠ¶æ¨¡å‹</label>
            <button class="shape-btn active" data-shape="heart">â¤ï¸ çˆ±å¿ƒ (Heart)</button>
            <button class="shape-btn" data-shape="flower">ğŸŒ¸ èŠ±æœµ (Abstract)</button>
            <button class="shape-btn" data-shape="saturn">ğŸª åœŸæ˜Ÿ (Saturn)</button>
            <button class="shape-btn" data-shape="buddha">ğŸ§˜ ä½›åƒ (Abstract)</button>
            <button class="shape-btn" data-shape="fireworks">ğŸ† çƒŸèŠ± (Chaos)</button>
        </div>
        <div class="ui-group">
             <label>ç²’å­é¢œè‰²</label>
            <input type="color" id="color-picker" value="#007bff">
        </div>
    </div>
    <button id="fullscreen-btn">â›¶ å…¨å±æ¨¡å¼</button>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <script>
        let scene, camera, renderer, particleSystem, uniforms;
        let handOpenFactor = 0; // 0 = æ¡æ‹³ (èšé›†), 1 = å¼ å¼€ (æ‰©æ•£)
        const PARTICLE_COUNT = 30000; // ç²’å­æ•°é‡
        const videoElement = document.createElement('video');
        videoElement.classList.add('input_video');
        document.body.appendChild(videoElement);

        // ==========================================
        // 1. Three.js æ ¸å¿ƒåœºæ™¯è®¾ç½®
        // ==========================================
        function initThree() {
            const container = document.getElementById('canvas-container');
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x000000, 0.001);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 100;

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            container.appendChild(renderer.domElement);

            window.addEventListener('resize', onWindowResize, false);
            setupFullscreen();
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function setupFullscreen() {
            const btn = document.getElementById('fullscreen-btn');
            btn.addEventListener('click', () => {
                if (!document.fullscreenElement) {
                    document.documentElement.requestFullscreen();
                } else {
                    if (document.exitFullscreen) document.exitFullscreen();
                }
            });
        }

        // ==========================================
        // 2. ç²’å­ç³»ç»Ÿä¸ç€è‰²å™¨ (æ ¸å¿ƒéƒ¨åˆ†)
        // ==========================================
        // é¡¶ç‚¹ç€è‰²å™¨ï¼šå¤„ç†ç²’å­çš„ä½ç½®ï¼Œæ ¹æ®æ‰‹åŠ¿åœ¨ç›®æ ‡å½¢æ€å’Œæ‰©æ•£å½¢æ€é—´æ’å€¼
        const vertexShader = `
            uniform float uTime;
            uniform float uHandOpenFactor; // æ‰‹åŠ¿å¼ å¼€ç¨‹åº¦ 0.0 - 1.0
            uniform float uScale;
            attribute vec3 aTargetPosition; // ç²’å­åº”è¯¥å»çš„å½¢çŠ¶ä½ç½®
            attribute vec3 aRandomOffset;   // ç²’å­æ‰©æ•£æ—¶çš„éšæœºæ–¹å‘

            varying vec3 vColor;

            void main() {
                // åŸºç¡€ç›®æ ‡ä½ç½®
                vec3 target = aTargetPosition;

                // æ‰©æ•£çŠ¶æ€ï¼šå‘å¤–çˆ†ç‚¸ï¼Œå¹¶åŠ ä¸Šä¸€äº›åŸºäºæ—¶é—´çš„å™ªç‚¹ç§»åŠ¨
                vec3 diffusedState = aTargetPosition + normalize(aRandomOffset) * (50.0 + sin(uTime * aRandomOffset.x) * 10.0);

                // æ ¸å¿ƒäº¤äº’ï¼šæ ¹æ®æ‰‹åŠ¿åœ¨èšé›†å’Œæ‰©æ•£çŠ¶æ€é—´æ··åˆ (mix)
                vec3 finalPosition = mix(target, diffusedState, uHandOpenFactor);

                // æ•´ä½“ç¼©æ”¾æ§åˆ¶ (æ¡æ‹³æ—¶ç¨å¾®å˜å°)
                float dynamicScale = uScale * (1.0 - uHandOpenFactor * 0.3);
                
                vec4 mvPosition = modelViewMatrix * vec4(finalPosition * dynamicScale, 1.0);
                
                // ç²’å­å¤§å°éšè·ç¦»è¡°å‡
                gl_PointSize = (3.0 * (1.0 + uHandOpenFactor * 2.0)) * (300.0 / -mvPosition.z);
                gl_Position = projectionMatrix * mvPosition;
            }
        `;

        // ç‰‡å…ƒç€è‰²å™¨ï¼šå¤„ç†ç²’å­é¢œè‰²å’Œåœ†å½¢å¤–è§‚
        const fragmentShader = `
            uniform vec3 uColor;
            void main() {
                // æŠŠæ–¹å½¢çš„ç‚¹å˜æˆåœ†å½¢çš„
                float dist = length(gl_PointCoord - vec2(0.5));
                if (dist > 0.5) discard;

                // ç®€å•çš„å¾„å‘æ¸å˜ï¼Œä¸­å¿ƒäº®è¾¹ç¼˜æš—
                float alpha = 1.0 - smoothstep(0.3, 0.5, dist);
                gl_FragColor = vec4(uColor, alpha);
            }
        `;

        function createParticleSystem(shapeName) {
            if (particleSystem) scene.remove(particleSystem);

            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(PARTICLE_COUNT * 3);
            const targetPositions = new Float32Array(PARTICLE_COUNT * 3);
            const randomOffsets = new Float32Array(PARTICLE_COUNT * 3);

            // è·å–ç›®æ ‡å½¢çŠ¶çš„æ‰€æœ‰ç‚¹æ•°æ®
            const shapePoints = generateShapePoints(shapeName, PARTICLE_COUNT);

            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const i3 = i * 3;
                // åˆå§‹ä½ç½®éƒ½åœ¨ä¸­å¿ƒ
                positions[i3] = 0; positions[i3 + 1] = 0; positions[i3 + 2] = 0;
                
                // ç›®æ ‡ä½ç½®
                targetPositions[i3] = shapePoints[i].x;
                targetPositions[i3 + 1] = shapePoints[i].y;
                targetPositions[i3 + 2] = shapePoints[i].z;

                // éšæœºæ‰©æ•£æ–¹å‘
                randomOffsets[i3] = (Math.random() - 0.5) * 2;
                randomOffsets[i3 + 1] = (Math.random() - 0.5) * 2;
                randomOffsets[i3 + 2] = (Math.random() - 0.5) * 2;
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('aTargetPosition', new THREE.BufferAttribute(targetPositions, 3));
            geometry.setAttribute('aRandomOffset', new THREE.BufferAttribute(randomOffsets, 3));

            // è·å–å½“å‰é€‰æ‹©çš„é¢œè‰²
            const colorHex = document.getElementById('color-picker').value;
            const initialColor = new THREE.Color(colorHex);

            uniforms = {
                uTime: { value: 0 },
                uHandOpenFactor: { value: 0 }, // è¿™ä¸ªå€¼å°†ç”± MediaPipe æ§åˆ¶
                uScale: { value: 1.0 },
                uColor: { value: initialColor }
            };

            const material = new THREE.ShaderMaterial({
                uniforms: uniforms,
                vertexShader: vertexShader,
                fragmentShader: fragmentShader,
                transparent: true,
                depthWrite: false,
                blending: THREE.AdditiveBlending // å‘å…‰å åŠ æ¨¡å¼
            });

            particleSystem = new THREE.Points(geometry, material);
            scene.add(particleSystem);
        }

        // ==========================================
        // 3. å½¢çŠ¶ç”Ÿæˆå™¨ (æ•°å­¦æ–¹æ³•ç”Ÿæˆç‚¹äº‘)
        // ==========================================
        // è¾…åŠ©å‡½æ•°ï¼šä» Three.js å‡ ä½•ä½“ä¸­æå–éšæœºç‚¹
        function sampleGeometry(geometry, count) {
            const material = new THREE.MeshBasicMaterial();
            const mesh = new THREE.Mesh(geometry, material);
            const sampler = new THREE.MeshSurfaceSampler(mesh).build();
            const points = [];
            const tempPosition = new THREE.Vector3();
            for (let i = 0; i < count; i++) {
                sampler.sample(tempPosition);
                points.push(tempPosition.clone());
            }
            return points;
        }
        
        function generateShapePoints(shape, count) {
            const points = [];
            let vec = new THREE.Vector3();
            switch (shape) {
                case 'heart':
                    for (let i = 0; i < count; i++) {
                        let t = Math.random() * Math.PI * 2;
                        // çˆ±å¿ƒå‚æ•°æ–¹ç¨‹
                        let x = 16 * Math.pow(Math.sin(t), 3);
                        let y = 13 * Math.cos(t) - 5 * Math.cos(2 * t) - 2 * Math.cos(3 * t) - Math.cos(4 * t);
                        let z = (Math.random() - 0.5) * 10; // ç»™ä¸€ç‚¹åšåº¦
                        vec.set(x, y, z).multiplyScalar(2.5); // ç¼©æ”¾
                        points.push(vec.clone());
                    }
                    break;
                case 'saturn':
                    for (let i = 0; i < count; i++) {
                        // ä¸»ä½“çƒä½“ (30% ç²’å­)
                        if (i < count * 0.3) {
                             vec.randomDirection().multiplyScalar(Math.random() * 20);
                        } else {
                        // å…‰ç¯ (70% ç²’å­)
                            const angle = Math.random() * Math.PI * 2;
                            const radius = 30 + Math.random() * 20;
                            vec.set(Math.cos(angle) * radius, (Math.random()-0.5)*2, Math.sin(angle) * radius);
                            vec.applyAxisAngle(new THREE.Vector3(1,0,0.5).normalize(), Math.PI/6); // å€¾æ–œå…‰ç¯
                        }
                        points.push(vec.clone());
                    }
                    break;
                case 'flower':
                    // ä½¿ç”¨ TorusKnotGeometry è¿‘ä¼¼æŠ½è±¡èŠ±æœµ
                    const flowerGeo = new THREE.TorusKnotGeometry(25, 8, 150, 20, 3, 7);
                    return sampleGeometry(flowerGeo, count);
                case 'buddha':
                    // ä½¿ç”¨å¤æ‚çš„ TorusKnot è¿‘ä¼¼ä¸€ä¸ªå¤æ‚çš„ååƒæŠ½è±¡
                     const buddhaGeo = new THREE.TorusKnotGeometry(20, 6, 200, 30, 2, 3);
                     // ç¨å¾®å‹æ‰ä¸€ç‚¹
                     buddhaGeo.scale(1, 1.2, 0.8);
                    return sampleGeometry(buddhaGeo, count);
                case 'fireworks':
                default:
                    for (let i = 0; i < count; i++) {
                        // éšæœºçƒä½“åˆ†å¸ƒ
                        vec.randomDirection().multiplyScalar(Math.random() * 60);
                        points.push(vec.clone());
                    }
                    break;
            }
            return points;
        }

        // ==========================================
        // 4. MediaPipe Hands é›†æˆ (æ‰‹åŠ¿è¯†åˆ«)
        // ==========================================
        function initMediaPipe() {
            const hands = new Hands({locateFile: (file) => {
                return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
            }});

            hands.setOptions({
                maxNumHands: 1, // åªæ£€æµ‹ä¸€åªæ‰‹
                modelComplexity: 1,
                minDetectionConfidence: 0.5,
                minTrackingConfidence: 0.5
            });

            hands.onResults(onHandsResults);

            const cameraMP = new Camera(videoElement, {
                onFrame: async () => {
                    await hands.send({image: videoElement});
                },
                width: 640,
                height: 480
            });
            cameraMP.start()
            .then(() => {
                document.getElementById('loading').style.display = 'none';
            })
            .catch(err => {
                document.getElementById('loading').innerText = 'æ‘„åƒå¤´å¯åŠ¨å¤±è´¥ï¼Œè¯·æ£€æŸ¥æƒé™ã€‚';
                console.error(err);
            });
        }

        function onHandsResults(results) {
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const landmarks = results.multiHandLandmarks[0];
                
                // è®¡ç®—æ‰‹æŒå¼ å¼€ç¨‹åº¦çš„ç®€å•ç®—æ³•ï¼š
                // è®¡ç®—é£ŸæŒ‡æŒ‡å°–(8)åˆ°æ‰‹è…•(0)çš„è·ç¦»ï¼Œä»¥åŠå°æŒ‡æŒ‡å°–(20)åˆ°æ‰‹è…•(0)çš„è·ç¦»å¹³å‡å€¼ã€‚
                // è·ç¦»è¶Šå¤§ï¼Œæ‰‹è¶Šå¼ å¼€ã€‚
                const wrist = landmarks[0];
                const indexTip = landmarks[8];
                const pinkyTip = landmarks[20];
                
                const distIndex = Math.sqrt(Math.pow(indexTip.x - wrist.x, 2) + Math.pow(indexTip.y - wrist.y, 2));
                const distPinky = Math.sqrt(Math.pow(pinkyTip.x - wrist.x, 2) + Math.pow(pinkyTip.y - wrist.y, 2));
                const avgDist = (distIndex + distPinky) / 2;

                // æ ¹æ®ç»éªŒå€¼æ˜ å°„åˆ° 0~1 ä¹‹é—´ã€‚é€šå¸¸æ¡æ‹³è·ç¦»çº¦ä¸º 0.2ï¼Œå¼ å¼€çº¦ä¸º 0.5ä»¥ä¸Šã€‚
                // æ˜ å°„èŒƒå›´ [0.2, 0.5] -> [0, 1]
                let targetFactor = (avgDist - 0.2) / (0.5 - 0.2);
                targetFactor = Math.max(0, Math.min(1, targetFactor)); // é’³åˆ¶åœ¨ 0-1

                // ä½¿ç”¨ç®€å•çš„çº¿æ€§æ’å€¼ (Lerp) å¹³æ»‘æ•°å€¼ï¼Œé˜²æ­¢æŠ–åŠ¨
                handOpenFactor += (targetFactor - handOpenFactor) * 0.1;

            } else {
                // å¦‚æœæ²¡æœ‰æ£€æµ‹åˆ°æ‰‹ï¼Œç¼“æ…¢å›åˆ°æ¡æ‹³çŠ¶æ€ï¼ˆèšé›†ï¼‰
                handOpenFactor += (0 - handOpenFactor) * 0.05;
            }
        }

        // ==========================================
        // 5. UI äº¤äº’é€»è¾‘
        // ==========================================
        function setupUI() {
            // å½¢çŠ¶åˆ‡æ¢
            const shapeBtns = document.querySelectorAll('.shape-btn');
            shapeBtns.forEach(btn => {
                btn.addEventListener('click', (e) => {
                    shapeBtns.forEach(b => b.classList.remove('active'));
                    e.target.classList.add('active');
                    const shape = e.target.dataset.shape;
                    createParticleSystem(shape);
                });
            });

            // é¢œè‰²åˆ‡æ¢
            const colorPicker = document.getElementById('color-picker');
            colorPicker.addEventListener('input', (e) => {
                if (uniforms) {
                    uniforms.uColor.value.set(e.target.value);
                }
            });
        }

        // ==========================================
        // 6. ä¸»å¾ªç¯
        // ==========================================
        function animate() {
            requestAnimationFrame(animate);
            
            if (uniforms) {
                // æ›´æ–°æ—¶é—´
                uniforms.uTime.value += 0.02;
                // æ›´æ–°æ‰‹åŠ¿å› å­åˆ° Shader
                uniforms.uHandOpenFactor.value = handOpenFactor;
                // è®©æ•´ä¸ªç³»ç»Ÿç¼“æ…¢æ—‹è½¬
                particleSystem.rotation.y += 0.002;
            }

            renderer.render(scene, camera);
        }

        // ==========================================
        // å¯åŠ¨åº”ç”¨
        // ==========================================
        initThree();
        // åˆå§‹åŠ è½½é»˜è®¤å½¢çŠ¶
        createParticleSystem('heart');
        setupUI();
        // å¯åŠ¨ MediaPipeï¼ˆéœ€è¦æ‘„åƒå¤´ï¼‰
        initMediaPipe();
        animate();

    </script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/math/MeshSurfaceSampler.js"></script>
</body>
</html>