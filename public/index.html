<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cinematic Christmas AR (Mouse Pick Supported)</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #050505; font-family: 'Arial', sans-serif; user-select: none; }
        #canvas-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; }
        
        /* UI é¢æ¿ */
        #ui-panel {
            position: absolute; top: 20px; left: 20px; width: 240px;
            background: rgba(10, 15, 12, 0.85);
            backdrop-filter: blur(12px);
            padding: 20px; border-radius: 8px; color: #d4af37; z-index: 10;
            border: 1px solid rgba(212, 175, 55, 0.2);
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            pointer-events: none; /* è®©é¼ æ ‡ç©¿é€UIï¼Œä¸å½±å“ç‚¹å‡»åœºæ™¯ */
        }
        
        .ui-header { 
            font-size: 10px; letter-spacing: 3px; color: #888; 
            margin-bottom: 15px; font-weight: 800; border-bottom: 1px solid #333; 
            padding-bottom: 5px; 
        }
        
        .status-text { 
            font-size: 16px; color: #fff; 
            text-shadow: 0 0 10px rgba(212, 175, 55, 0.6); 
            font-weight: bold; margin-bottom: 20px; 
        }

        .hint-container { display: none; transition: opacity 0.5s;}
        .hint-container.active { display: block; opacity: 1; }
        
        .hint-row { 
            display: flex; align-items: center; gap: 10px; margin-bottom: 8px; 
            font-size: 12px; color: #aaa; 
        }
        .icon { width: 20px; text-align: center; display: inline-block;}
        .highlight { color: #00ffff; font-weight: bold; }

        /* åŠ è½½åŠ¨ç”» */
        #loader {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: #020202; z-index: 100;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            transition: opacity 0.8s ease;
        }
        .spinner {
            width: 40px; height: 40px; border: 2px solid #333; 
            border-top: 2px solid #d4af37; border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        video { display: none; }
    </style>
</head>
<body>

    <div id="loader">
        <div class="spinner"></div>
        <div style="color:#666; margin-top:20px; letter-spacing:2px; font-size:12px;">INITIALIZING SYSTEM...</div>
    </div>

    <div id="ui-panel">
        <div class="ui-header">SYSTEM STATUS</div>
        <div id="status-text" class="status-text">DETECTING INPUT...</div>
        
        <div class="ui-header">CONTROLS</div>
        
        <div id="hint-cam" class="hint-container">
            <div class="hint-row"><span class="icon">ğŸ–±ï¸</span> <span class="highlight">ç‚¹å‡»ç…§ç‰‡</span> ç›´æ¥é€‰ä¸­</div>
            <div class="hint-row"><span class="icon">âœŠ</span> æ¡æ‹³èšåˆ (Tree)</div>
            <div class="hint-row"><span class="icon">ğŸ–</span> å¼ æ‰‹æ•£å¼€ (Burst)</div>
            <div class="hint-row"><span class="icon">ğŸ‘Œ</span> æåˆé€‰ä¸­ (Zoom)</div>
            <div class="hint-row"><span class="icon">ğŸ‘‹</span> æ‰‹æŒç§»åŠ¨è§†è§’</div>
        </div>

        <div id="hint-mouse" class="hint-container">
            <div class="hint-row"><span class="icon">ğŸ–±ï¸</span> <span class="highlight">å·¦é”®ç‚¹å‡»ç…§ç‰‡</span> é€‰ä¸­</div>
            <div class="hint-row"><span class="icon">ğŸ–±ï¸</span> å·¦é”®é•¿æŒ‰ç©ºç™½å¤„èšåˆ</div>
            <div class="hint-row"><span class="icon">â†”ï¸</span> é¼ æ ‡ç§»åŠ¨è§†è§’</div>
            <div class="hint-row" style="color:#666; margin-top:5px; font-style:italic;">* é¼ æ ‡æ¨¡å¼å·²æ¿€æ´»</div>
        </div>
    </div>

    <div id="canvas-container"></div>
    <video id="input_video"></video>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        // ================= é…ç½® =================
        const CONFIG = {
            particleCount: 500,
            photoCount: 12,
            treeHeight: 80,
            explodeRadius: 130,
            camZ: 110,
            colors: { gold: 0xFFD700, red: 0x8B0000, green: 0x2F4F4F }
        };

        // ================= å…¨å±€çŠ¶æ€ =================
        let scene, camera, renderer, composer;
        let particles = []; 
        let photos = []; // ä¸“é—¨å­˜å‚¨ç…§ç‰‡Meshç”¨äºå°„çº¿æ£€æµ‹
        let targetState = 'EXPLODE'; 
        let activePhotoIdx = -1;

        // å°„çº¿æ£€æµ‹ (Mouse Picking)
        const raycaster = new THREE.Raycaster();
        const mouseVector = new THREE.Vector2(); // ç”¨äºå°„çº¿æ£€æµ‹çš„å½’ä¸€åŒ–åæ ‡
        let hoveredPhoto = null;

        // è¾“å…¥çŠ¶æ€
        const inputState = {
            x: 0.5, y: 0.5,     // è§†è§’æ§åˆ¶åæ ‡
            isFist: false,      // æ¡æ‹³/é•¿æŒ‰èƒŒæ™¯
            isPinch: false,     // æåˆ
            forcePhotoSelection: false, // å¼ºåˆ¶ç…§ç‰‡é€‰ä¸­æ¨¡å¼ (ç‚¹å‡»è§¦å‘)
            isActive: false     
        };

        // ================= 1. æ ¸å¿ƒæ¸²æŸ“é€»è¾‘ =================
        function initThree() {
            const container = document.getElementById('canvas-container');
            
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x020202, 0.002);

            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = CONFIG.camZ;

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.1;
            container.appendChild(renderer.domElement);

            // ç¯å…‰
            const ambient = new THREE.AmbientLight(0x222222, 3);
            scene.add(ambient);
            const mainLight = new THREE.DirectionalLight(0xfffaed, 2);
            mainLight.position.set(20, 50, 50);
            scene.add(mainLight);
            
            // è¾‰å…‰
            const renderPass = new RenderPass(scene, camera);
            const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
            bloomPass.threshold = 0.15; bloomPass.strength = 0.6; bloomPass.radius = 0.8;
            composer = new EffectComposer(renderer);
            composer.addPass(renderPass);
            composer.addPass(bloomPass);

            createObjects();
            
            // å…¨å±€é¼ æ ‡ç›‘å¬ (ç”¨äºå°„çº¿æ£€æµ‹ï¼Œç‹¬ç«‹äºæ‰‹åŠ¿æ¨¡å¼)
            window.addEventListener('mousemove', onGlobalMouseMove);
            window.addEventListener('mousedown', onGlobalMouseDown);
            window.addEventListener('mouseup', () => { inputState.isFist = false; });
            window.addEventListener('resize', onWindowResize);
        }

        // å°„çº¿æ£€æµ‹æ ¸å¿ƒé€»è¾‘
        function onGlobalMouseMove(event) {
            // æ›´æ–°å°„çº¿åæ ‡ (-1 åˆ° +1)
            mouseVector.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouseVector.y = -(event.clientY / window.innerHeight) * 2 + 1;

            // å¦‚æœå¤„äºé¼ æ ‡æ¨¡å¼ï¼ŒåŒæ—¶ä¹Ÿæ›´æ–°è§†è§’åæ ‡ (0 åˆ° 1)
            if (document.body.dataset.mode === 'mouse') {
                inputState.x = event.clientX / window.innerWidth;
                inputState.y = event.clientY / window.innerHeight;
            }

            checkIntersection();
        }

        function checkIntersection() {
            raycaster.setFromCamera(mouseVector, camera);
            const intersects = raycaster.intersectObjects(photos);

            if (intersects.length > 0) {
                // é¼ æ ‡æ‚¬åœåœ¨ç…§ç‰‡ä¸Š
                if (hoveredPhoto !== intersects[0].object) {
                    hoveredPhoto = intersects[0].object;
                    document.body.style.cursor = 'pointer';
                    // ç®€å•çš„æ‚¬åœé«˜äº®æ•ˆæœ (å˜å¤§ä¸€ç‚¹ç‚¹)
                    hoveredPhoto.scale.multiplyScalar(1.1); 
                }
            } else {
                if (hoveredPhoto) {
                    // æ¢å¤
                    document.body.style.cursor = 'default';
                    hoveredPhoto = null;
                }
            }
        }

        function onGlobalMouseDown(event) {
            if (event.button !== 0) return; // ä»…é™å·¦é”®

            if (hoveredPhoto) {
                // === ç‚¹å‡»äº†ç…§ç‰‡ ===
                inputState.forcePhotoSelection = true; // é”å®šçŠ¶æ€
                activePhotoIdx = hoveredPhoto.userData.idx;
                inputState.isFist = false; // ç¡®ä¿ä¸ä¼šè§¦å‘èšåˆ
                
                // æ›´æ–°UIåé¦ˆ
                const statusEl = document.getElementById('status-text');
                statusEl.innerText = `SELECTED: MEMORY #${activePhotoIdx + 1}`;
                statusEl.style.color = "#00ffff";
            } else {
                // === ç‚¹å‡»äº†ç©ºç™½å¤„ ===
                // åªæœ‰åœ¨é¼ æ ‡æ¨¡å¼ä¸‹ï¼Œç‚¹å‡»ç©ºç™½å¤„æ‰ç®—ä½œâ€œæ¡æ‹³/èšåˆâ€
                // å¦‚æœæ˜¯æ‰‹åŠ¿æ¨¡å¼ï¼Œé¼ æ ‡ç‚¹å‡»ç©ºç™½å¤„ä¸åšæ“ä½œï¼Œä»¥å…å¹²æ‰°æ‰‹åŠ¿
                if (document.body.dataset.mode === 'mouse') {
                    inputState.forcePhotoSelection = false; // å–æ¶ˆç…§ç‰‡é”å®š
                    inputState.isFist = true;
                } else {
                    // æ‰‹åŠ¿æ¨¡å¼ä¸‹ï¼Œç‚¹å‡»ç©ºç™½å¤„å¯ä»¥å–æ¶ˆç…§ç‰‡é€‰ä¸­ï¼Œå›åˆ°æ•£å¼€æ€
                    inputState.forcePhotoSelection = false;
                }
            }
        }

        function createPlaceholderTexture(idx) {
            const canvas = document.createElement('canvas');
            canvas.width = 256; canvas.height = 340;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#f5f5f5'; ctx.fillRect(0,0,256,340);
            const hue = (idx * 137.5) % 360; // é»„é‡‘è§’é¢œè‰²åˆ†å¸ƒ
            ctx.fillStyle = `hsl(${hue}, 50%, 25%)`; ctx.fillRect(15,15,226,226);
            
            // ç»˜åˆ¶ä¸€äº›ç®€å•çš„å›¾å½¢æ¨¡æ‹Ÿç…§ç‰‡å†…å®¹
            ctx.fillStyle = 'rgba(255,255,255,0.2)';
            ctx.beginPath(); ctx.arc(128, 128, 50, 0, Math.PI*2); ctx.fill();
            
            ctx.font = 'bold 28px serif'; ctx.fillStyle = '#d4af37'; ctx.textAlign = 'center';
            ctx.fillText(`MOMENT ${idx+1}`, 128, 300);
            return new THREE.CanvasTexture(canvas);
        }

        function createObjects() {
            const matGold = new THREE.MeshStandardMaterial({ color: CONFIG.colors.gold, roughness: 0.2, metalness: 0.9 });
            const matRed = new THREE.MeshStandardMaterial({ color: CONFIG.colors.red, roughness: 0.4, metalness: 0.4 });
            const matGreen = new THREE.MeshStandardMaterial({ color: CONFIG.colors.green, roughness: 0.9, metalness: 0.1 });
            
            const geoms = [
                new THREE.SphereGeometry(1, 16, 16),
                new THREE.BoxGeometry(1.5, 1.5, 1.5),
                new THREE.IcosahedronGeometry(1.2)
            ];

            // è£…é¥°ç²’å­
            for(let i=0; i<CONFIG.particleCount; i++) {
                const rnd = Math.random();
                const mat = rnd > 0.6 ? matGold : (rnd > 0.3 ? matRed : matGreen);
                const geom = geoms[Math.floor(Math.random()*geoms.length)];
                const mesh = new THREE.Mesh(geom, mat);
                initParticle(mesh, 'DECOR', i);
                scene.add(mesh);
                particles.push(mesh);
            }

            // ç…§ç‰‡
            const photoGeo = new THREE.PlaneGeometry(8, 10.5);
            const borderGeo = new THREE.PlaneGeometry(8.5, 11);
            for(let i=0; i<CONFIG.photoCount; i++) {
                const tex = createPlaceholderTexture(i);
                const mat = new THREE.MeshBasicMaterial({ map: tex, side: THREE.DoubleSide });
                const mesh = new THREE.Mesh(photoGeo, mat);
                const border = new THREE.Mesh(borderGeo, matGold);
                border.position.z = -0.1;
                mesh.add(border);
                
                initParticle(mesh, 'PHOTO', i);
                scene.add(mesh);
                particles.push(mesh);
                photos.push(mesh); // æ·»åŠ åˆ°æ£€æµ‹æ•°ç»„
            }
        }

        function initParticle(mesh, type, idx) {
            const h = Math.random();
            const angle = h * Math.PI * 18 + Math.random();
            const r = (1.1 - h) * 35 + Math.random()*5;
            const treePos = new THREE.Vector3(Math.cos(angle)*r, (h-0.5)*80, Math.sin(angle)*r);

            const phi = Math.acos(2*Math.random()-1);
            const theta = Math.random()*Math.PI*2;
            const rad = 40 + Math.random()*CONFIG.explodeRadius;
            const explodePos = new THREE.Vector3(
                rad*Math.sin(phi)*Math.cos(theta),
                rad*Math.sin(phi)*Math.sin(theta),
                rad*Math.cos(phi)
            );

            mesh.userData = {
                type, idx, treePos, explodePos,
                rotSpeed: {x: (Math.random()-0.5)*0.03, y: (Math.random()-0.5)*0.03},
                baseScale: mesh.scale.clone()
            };
            mesh.position.copy(explodePos);
        }

        // ================= 2. çŠ¶æ€æœºä¸åŠ¨ç”» =================
        function updateLogic() {
            const statusEl = document.getElementById('status-text');
            
            // ä¼˜å…ˆçº§é€»è¾‘ï¼šå¼ºåˆ¶ç…§ç‰‡é€‰æ‹© > æåˆæ‰‹åŠ¿ > æ¡æ‹³æ‰‹åŠ¿ > é»˜è®¤æ•£å¼€
            if (inputState.forcePhotoSelection) {
                targetState = 'PHOTO';
                // çŠ¶æ€æ–‡æœ¬åœ¨ç‚¹å‡»äº‹ä»¶ä¸­å·²æ›´æ–°
            } else if (inputState.isPinch) {
                if (targetState !== 'PHOTO') {
                    targetState = 'PHOTO';
                    activePhotoIdx = (activePhotoIdx + 1) % CONFIG.photoCount; // éšæœºåˆ‡æ¢
                    statusEl.innerText = "ZOOMING MEMORY";
                    statusEl.style.color = "#00ffff";
                }
            } else if (inputState.isFist) {
                targetState = 'TREE';
                statusEl.innerText = "FORMING TREE";
                statusEl.style.color = "#d4af37";
            } else {
                targetState = 'EXPLODE';
                statusEl.innerText = "WANDERING STARS";
                statusEl.style.color = "#ff4466";
            }

            // è§†è§‰åŠ¨ç”»
            const time = Date.now() * 0.001;
            
            const targetRotY = (inputState.x - 0.5) * 1.5;
            const targetRotX = (inputState.y - 0.5) * 1.0;
            scene.rotation.y += (targetRotY - scene.rotation.y) * 0.05;
            scene.rotation.x += (targetRotX - scene.rotation.x) * 0.05;

            particles.forEach(mesh => {
                const data = mesh.userData;
                let tPos = new THREE.Vector3();
                let tScale = data.baseScale.clone();

                if (targetState === 'TREE') {
                    tPos.copy(data.treePos);
                    tPos.y += Math.sin(time*2 + tPos.x)*0.5;
                    if(data.type === 'PHOTO') tScale.multiplyScalar(0.5);
                } 
                else if (targetState === 'EXPLODE') {
                    tPos.copy(data.explodePos);
                    tPos.x += Math.sin(time + data.idx)*2;
                    tPos.y += Math.cos(time*0.8 + data.idx)*2;
                }
                else if (targetState === 'PHOTO') {
                    if (data.type === 'PHOTO' && data.idx === activePhotoIdx) {
                        tPos.set(0, 0, CONFIG.camZ - 25);
                        tScale.multiplyScalar(3.5);
                        mesh.lookAt(camera.position);
                        mesh.renderOrder = 999;
                        // ç‰¹æ®Šæ’å€¼
                        mesh.position.lerp(tPos, 0.1);
                        mesh.scale.lerp(tScale, 0.1);
                        return;
                    } else {
                        tPos.copy(data.explodePos).multiplyScalar(1.8);
                    }
                }

                mesh.position.lerp(tPos, 0.06);
                mesh.scale.lerp(tScale, 0.1);
                mesh.rotation.x += data.rotSpeed.x;
                mesh.rotation.y += data.rotSpeed.y;
                mesh.renderOrder = 0;
            });
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            updateLogic();
            composer.render();
        }

        // ================= 3. è¾“å…¥å¤„ç†é€‚é…å™¨ =================
        function enableMouseMode() {
            document.body.dataset.mode = 'mouse'; // æ ‡è®°å½“å‰æ¨¡å¼
            document.getElementById('hint-cam').classList.remove('active');
            document.getElementById('hint-mouse').classList.add('active');
            document.getElementById('status-text').innerText = "MOUSE MODE ACTIVE";
            
            const loader = document.getElementById('loader');
            loader.style.opacity = 0;
            setTimeout(() => loader.remove(), 800);
            
            // æ³¨æ„ï¼šmousemove å’Œ mousedown å·²åœ¨ initThree å…¨å±€ç»‘å®š
            // è¿™é‡Œåªéœ€å¤„ç†å³é”®ç­‰ç‰¹æ®Šé€»è¾‘
            window.addEventListener('contextmenu', e => e.preventDefault());
        }

        function initMediaPipe() {
            const video = document.getElementById('input_video');
            const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
            
            hands.setOptions({
                maxNumHands: 1,
                modelComplexity: 1,
                minDetectionConfidence: 0.5,
                minTrackingConfidence: 0.5
            });

            hands.onResults(results => {
                if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                    const lm = results.multiHandLandmarks[0];
                    inputState.isActive = true;
                    
                    // æ‰‹åŠ¿æ˜ å°„
                    inputState.x = 1.0 - lm[9].x; 
                    inputState.y = lm[9].y;

                    // æ¡æ‹³æ£€æµ‹
                    const tips = [8, 12, 16, 20];
                    let avgDist = 0;
                    tips.forEach(i => avgDist += Math.hypot(lm[i].x - lm[0].x, lm[i].y - lm[0].y));
                    avgDist /= 4;
                    inputState.isFist = avgDist < 0.25;

                    // æåˆæ£€æµ‹
                    const pinchDist = Math.hypot(lm[4].x - lm[8].x, lm[4].y - lm[8].y);
                    inputState.isPinch = pinchDist < 0.05;
                    
                    // å¦‚æœæ‰‹åŠ¿è§¦å‘äº†æåˆæˆ–æ¡æ‹³ï¼Œæ‰“æ–­é¼ æ ‡é€‰ä¸­çš„é”å®šçŠ¶æ€
                    if (inputState.isFist || inputState.isPinch) {
                        inputState.forcePhotoSelection = false;
                    }
                }
            });

            const cam = new Camera(video, {
                onFrame: async () => { await hands.send({image: video}); },
                width: 640, height: 480
            });
            
            cam.start()
                .then(() => {
                    document.body.dataset.mode = 'camera';
                    document.getElementById('hint-cam').classList.add('active');
                    document.getElementById('loader').remove();
                })
                .catch((err) => {
                    console.warn("Camera failed/denied:", err);
                    enableMouseMode();
                });
        }

        initThree();
        initMediaPipe();
        animate();

    </script>
</body>
</html>