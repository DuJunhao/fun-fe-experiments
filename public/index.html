<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å¥¢åæµé‡‘åœ£è¯æ ‘ AR (ä¿®å¤ç‰ˆ)</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: sans-serif; user-select: none; }
        #canvas-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; }

        /* UI é¢æ¿ */
        #ui-panel {
            position: absolute; top: 20px; left: 20px; width: 180px;
            background: rgba(10, 10, 10, 0.6); backdrop-filter: blur(8px);
            padding: 15px; border-radius: 8px; color: #d4af37; z-index: 10;
            border: 1px solid rgba(212, 175, 55, 0.3);
            box-shadow: 0 0 20px rgba(212, 175, 55, 0.1);
        }
        .ui-label { font-size: 10px; letter-spacing: 2px; color: #888; margin-bottom: 8px; font-weight: bold; }
        .status-text { font-size: 14px; color: #fff; text-shadow: 0 0 5px gold; }

        /* åº•éƒ¨ç…§ç‰‡æ  */
        #gallery-container {
            position: absolute; bottom: 0; left: 0; width: 100%; height: 110px;
            background: linear-gradient(to top, #000, transparent);
            display: flex; align-items: center; overflow-x: auto; padding: 0 20px; z-index: 10; gap: 15px;
        }
        .gallery-item {
            height: 70px; width: 70px; object-fit: cover;
            border-radius: 4px; cursor: pointer; border: 1px solid #444;
            transition: all 0.3s; flex-shrink: 0; opacity: 0.6;
        }
        .gallery-item:hover { transform: scale(1.1); opacity: 1; border-color: gold; }
        .gallery-item.selected { border-color: gold; opacity: 1; box-shadow: 0 0 15px gold; transform: scale(1.1); }
        
        #loading-text { color: #888; font-size: 12px; width: 100%; text-align: center; }
        
        video { display: none; }
    </style>
</head>
<body>

    <div id="ui-panel">
        <div class="ui-label">STATUS</div>
        <div id="status-text" class="status-text">INITIALIZING...</div>
        <div class="ui-label" style="margin-top:15px">GESTURES</div>
        <div style="font-size:12px; color:#aaa;">âœŠ æ¡æ‹³: èšåˆæˆæ ‘</div>
        <div style="font-size:12px; color:#aaa;">ğŸ– å¼ å¼€: é‡‘ç²‰çˆ†ç‚¸</div>
        <div style="font-size:12px; color:#aaa;">ğŸ‘Œ æåˆ: æŠ“å–ç…§ç‰‡</div>
    </div>

    <div id="canvas-container"></div>
    <video id="input_video"></video>

    <div id="gallery-container">
        <div id="loading-text">æ­£åœ¨ä» Cloud Run è·å–åˆ—è¡¨...</div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <script>
        // ================= å…¨å±€å˜é‡ =================
        let scene, camera, renderer, goldParticles, itemParticles, photoMesh;
        let photoParticleGroups = []; // å­˜æ”¾ç…§ç‰‡ç²’å­
        let handOpenFactor = 0; // 0=æ ‘(æ¡æ‹³), 1=çˆ†ç‚¸(å¼ å¼€)
        let isMouseMode = false;
        let isPhotoMode = false;
        
        // ç²’å­æ•°é‡
        const GOLD_COUNT = 25000;
        const ITEM_COUNT = 300; 

        // ================= è¾…åŠ©ï¼šç¨‹åºåŒ–ç”Ÿæˆçº¹ç† (é˜²æ­¢Base64è·¨åŸŸ/åŠ è½½å¤±è´¥) =================
        function createSparkTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 32; canvas.height = 32;
            const context = canvas.getContext('2d');
            // ç”»ä¸€ä¸ªä¸­å¿ƒå‘å…‰çš„åœ†ç‚¹
            const gradient = context.createRadialGradient(16, 16, 0, 16, 16, 16);
            gradient.addColorStop(0, 'rgba(255,255,255,1)');
            gradient.addColorStop(0.2, 'rgba(255,215,0,1)'); // é‡‘è‰²
            gradient.addColorStop(0.5, 'rgba(255,215,0,0.2)');
            gradient.addColorStop(1, 'rgba(0,0,0,0)');
            context.fillStyle = gradient;
            context.fillRect(0, 0, 32, 32);
            
            const tex = new THREE.CanvasTexture(canvas);
            tex.needsUpdate = true;
            return tex;
        }

        // ================= Three.js åˆå§‹åŒ– =================
        function initThree() {
            const container = document.getElementById('canvas-container');
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x000000, 0.001); // é»‘è‰²è¿·é›¾

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);
            camera.position.z = 100;

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.outputEncoding = THREE.sRGBEncoding;
            container.appendChild(renderer.domElement);

            // ç”Ÿæˆçº¹ç† (ä¸å†ä¾èµ–å¤–éƒ¨å›¾ç‰‡)
            const sparkTexture = createSparkTexture();
            
            // --- ç³»ç»Ÿ1: é‡‘ç²‰ç²’å­ (ç»„æˆæ ‘çš„ä¸»ä½“) ---
            const goldGeo = new THREE.BufferGeometry();
            const goldPos = new Float32Array(GOLD_COUNT * 3);
            const goldTarget = new Float32Array(GOLD_COUNT * 3);
            const goldOffset = new Float32Array(GOLD_COUNT * 3);
            const goldColor = new Float32Array(GOLD_COUNT * 3);

            for(let i=0; i<GOLD_COUNT; i++) {
                const i3 = i*3;
                goldPos[i3]=0; goldPos[i3+1]=0; goldPos[i3+2]=0;
                
                // æ ‘å½¢ç›®æ ‡ (èºæ—‹åœ†é”¥)
                const h = Math.random(); // 0-1
                const angle = h * Math.PI * 18; 
                const r = (1-h) * 35 + Math.random()*2;
                goldTarget[i3] = Math.cos(angle)*r;
                goldTarget[i3+1] = (h-0.5)*90;
                goldTarget[i3+2] = Math.sin(angle)*r;

                // çˆ†ç‚¸åç§»
                goldOffset[i3] = (Math.random()-0.5)*2;
                goldOffset[i3+1] = (Math.random()-0.5)*2;
                goldOffset[i3+2] = (Math.random()-0.5)*2;

                // é¢œè‰²ï¼šé‡‘è‰²ä¸ºä¸»ï¼Œæ··å…¥å°‘é‡çº¢/ç™½
                const colorType = Math.random();
                const col = new THREE.Color();
                if(colorType > 0.9) col.setHex(0xFFFFFF); // ç™½é’»
                else if(colorType > 0.8) col.setHex(0xFF0000); // çº¢å®çŸ³
                else col.setHex(0xFFD700); // çº¯é‡‘
                
                goldColor[i3] = col.r; goldColor[i3+1] = col.g; goldColor[i3+2] = col.b;
            }
            goldGeo.setAttribute('position', new THREE.BufferAttribute(goldPos, 3));
            goldGeo.setAttribute('aTarget', new THREE.BufferAttribute(goldTarget, 3));
            goldGeo.setAttribute('aOffset', new THREE.BufferAttribute(goldOffset, 3));
            goldGeo.setAttribute('color', new THREE.BufferAttribute(goldColor, 3));

            const goldMat = new THREE.ShaderMaterial({
                uniforms: {
                    uTime: { value: 0 },
                    uFactor: { value: 0 },
                    uTex: { value: sparkTexture },
                    uIsPhoto: { value: 0 }
                },
                vertexShader: `
                    uniform float uTime;
                    uniform float uFactor; // 0=æ ‘, 1=ç‚¸
                    uniform float uIsPhoto;
                    attribute vec3 aTarget;
                    attribute vec3 aOffset;
                    attribute vec3 color;
                    varying vec3 vColor;
                    void main() {
                        vColor = color;
                        // æ ‘å½¢æ€
                        vec3 posTree = aTarget;
                        // åŠ ä¸Šæ—‹è½¬
                        float angle = uTime * 0.2;
                        float ca = cos(angle); float sa = sin(angle);
                        posTree.x = aTarget.x * ca - aTarget.z * sa;
                        posTree.z = aTarget.x * sa + aTarget.z * ca;

                        // çˆ†ç‚¸å½¢æ€
                        vec3 posExp = aTarget + normalize(aOffset) * (80.0 + sin(uTime*3.0+aOffset.x)*10.0);
                        
                        // æœ€ç»ˆæ··åˆ (ç…§ç‰‡æ¨¡å¼æ—¶å¼ºåˆ¶æ•£å¼€)
                        float finalFactor = mix(uFactor, 1.0, uIsPhoto * 0.9);
                        vec3 finalPos = mix(posTree, posExp, finalFactor);
                        
                        vec4 mvPosition = modelViewMatrix * vec4(finalPos, 1.0);
                        gl_Position = projectionMatrix * mvPosition;
                        gl_PointSize = (4.0 * (1.0+finalFactor)) * (300.0 / -mvPosition.z);
                    }
                `,
                fragmentShader: `
                    uniform sampler2D uTex;
                    varying vec3 vColor;
                    void main() {
                        vec4 tex = texture2D(uTex, gl_PointCoord);
                        if(tex.a < 0.1) discard;
                        gl_FragColor = vec4(vColor, tex.a);
                    }
                `,
                transparent: true,
                depthWrite: false,
                blending: THREE.AdditiveBlending // å…³é”®ï¼šå‘å…‰å åŠ 
            });
            goldParticles = new THREE.Points(goldGeo, goldMat);
            scene.add(goldParticles);

            // --- ç³»ç»Ÿ2: æ°›å›´æ¼‚æµ®ç‰© (ç¤¼ç‰©ã€ä¿¡å° - ç¨‹åºåŒ–å‡ ä½•ä½“) ---
            // è¿™é‡Œæˆ‘ä»¬ç”¨ InstancedMesh æ¥ç”»å¾ˆå¤šå°æ–¹å—ï¼Œä»£è¡¨ç¤¼ç‰©
            const giftGeo = new THREE.BoxGeometry(1.5, 1.5, 1.5);
            const giftMat = new THREE.MeshBasicMaterial({ color: 0xff3333 }); // çº¢è‰²ç¤¼ç‰©ç›’
            const giftMesh = new THREE.InstancedMesh(giftGeo, giftMat, ITEM_COUNT);
            
            const dummy = new THREE.Object3D();
            const giftOffsets = [];
            
            for(let i=0; i<ITEM_COUNT; i++) {
                // éšæœºåˆ†å¸ƒ
                const r = 20 + Math.random()*30;
                const theta = Math.random()*Math.PI*2;
                const y = (Math.random()-0.5)*90;
                
                dummy.position.set(Math.cos(theta)*r, y, Math.sin(theta)*r);
                dummy.rotation.set(Math.random()*Math.PI, Math.random()*Math.PI, 0);
                dummy.updateMatrix();
                giftMesh.setMatrixAt(i, dummy.matrix);
                
                // ä¿å­˜åˆå§‹ä½ç½®ç”¨äºåŠ¨ç”»
                giftOffsets.push({
                    x: Math.cos(theta)*r, 
                    y: y, 
                    z: Math.sin(theta)*r,
                    speed: Math.random() * 0.5 + 0.2
                });
            }
            giftMesh.userData = { offsets: giftOffsets }; // å­˜èµ·æ¥ç»™åŠ¨ç”»ç”¨
            scene.add(giftMesh);
            itemParticles = giftMesh; // å­˜åˆ°å…¨å±€å˜é‡

            // --- ç…§ç‰‡å±•ç¤ºå¹³é¢ ---
            photoMesh = new THREE.Mesh(
                new THREE.PlaneGeometry(1,1),
                new THREE.MeshBasicMaterial({ transparent: true, opacity: 0, side: THREE.DoubleSide })
            );
            // é‡‘è¾¹
            const outlineMat = new THREE.MeshBasicMaterial({ color: 0xFFD700, side: THREE.BackSide });
            const outline = new THREE.Mesh(new THREE.PlaneGeometry(1.05, 1.05), outlineMat);
            outline.position.z = -0.1;
            photoMesh.add(outline);
            
            scene.add(photoMesh);

            window.addEventListener('resize', onResize);
        }

        function onResize() {
            camera.aspect = window.innerWidth/window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // ================= äº¤äº’é€»è¾‘ =================
        async function loadGallery() {
            const container = document.getElementById('gallery-container');
            const status = document.getElementById('loading-text');
            const textureLoader = new THREE.TextureLoader();
            textureLoader.crossOrigin = "Anonymous";

            try {
                // è¯·æ±‚ Node.js åç«¯
                const res = await fetch('/api/images');
                const images = await res.json();
                
                container.innerHTML = '';
                if(images.length === 0) { status.innerText = "Bucketä¸ºç©º"; return; }

                // å¹¶è¡ŒåŠ è½½
                images.forEach((imgData, idx) => {
                    const url = imgData.url + "?t=" + Date.now();
                    
                    // DOM
                    const el = document.createElement('img');
                    el.src = url; el.className = 'gallery-item';
                    el.onclick = () => {
                        document.querySelectorAll('.gallery-item').forEach(e=>e.classList.remove('selected'));
                        el.classList.add('selected');
                        showPhoto(imgData.url);
                    };
                    if(idx===0) el.click();
                    container.appendChild(el);

                    // åŠ è½½ Three.js çº¹ç†ç”¨äºç²’å­åŒ–
                    textureLoader.load(url, (tex) => {
                        createPhotoParticles(tex);
                    });
                });
                status.remove();

            } catch(e) {
                console.error(e);
                status.innerText = "è¿æ¥åç«¯å¤±è´¥: " + e.message;
            }
        }

        // åˆ›å»ºç…§ç‰‡ç²’å­
        function createPhotoParticles(tex) {
            // æ¯å¼ ç…§ç‰‡ç”Ÿæˆä¸€ä¸ªå°ç²’å­äº‘
            const pCount = 40;
            const geo = new THREE.BufferGeometry();
            const pos = new Float32Array(pCount * 3);
            const base = new Float32Array(pCount * 3);
            
            for(let i=0; i<pCount; i++) {
                pos[i*3]=0; pos[i*3+1]=0; pos[i*3+2]=0;
                // éšæœºåˆ†å¸ƒ
                const r = 25 + Math.random()*40;
                const theta = Math.random()*Math.PI*2;
                base[i*3] = Math.cos(theta)*r;
                base[i*3+1] = (Math.random()-0.5)*100;
                base[i*3+2] = Math.sin(theta)*r;
            }
            geo.setAttribute('position', new THREE.BufferAttribute(pos, 3));
            geo.setAttribute('aBase', new THREE.BufferAttribute(base, 3));

            const mat = new THREE.PointsMaterial({
                size: 2.5,
                map: tex, // ä½¿ç”¨ç…§ç‰‡çº¹ç†
                transparent: true,
                opacity: 0.8,
                sizeAttenuation: true
            });
            
            const points = new THREE.Points(geo, mat);
            points.userData = { speed: Math.random() * 0.02 + 0.01 }; // æ—‹è½¬é€Ÿåº¦
            scene.add(points);
            photoParticleGroups.push(points);
        }

        function showPhoto(url) {
            isPhotoMode = true;
            const loader = new THREE.TextureLoader();
            loader.crossOrigin = "Anonymous";
            loader.load(url + "?t=" + Date.now(), (tex) => {
                const aspect = tex.image.width / tex.image.height;
                photoMesh.geometry.dispose();
                photoMesh.geometry = new THREE.PlaneGeometry(45*aspect, 45);
                photoMesh.material.map = tex;
                photoMesh.material.needsUpdate = true;
                // è¾¹æ¡†ä¹ŸåŒæ­¥
                photoMesh.children[0].geometry.dispose();
                photoMesh.children[0].geometry = new THREE.PlaneGeometry(45*aspect+1, 46);
            });
        }

        // ================= é™é»˜æ¨¡å¼åˆ‡æ¢ =================
        function switchToMouseMode() {
            if(isMouseMode) return;
            isMouseMode = true;
            document.getElementById('status-text').innerText = "MOUSE MODE ACTIVE";
            // é¼ æ ‡æ¨¡æ‹Ÿ
            document.addEventListener('mousemove', (e) => {
                handOpenFactor = 1.0 - (e.clientY / window.innerHeight);
                if(goldParticles) goldParticles.rotation.y = (e.clientX/window.innerWidth - 0.5) * 1.0;
            });
        }

        function initMediaPipe() {
            const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
            hands.setOptions({maxNumHands: 1, modelComplexity: 0, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5});
            
            hands.onResults(results => {
                if(results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                    isMouseMode = false;
                    const lm = results.multiHandLandmarks[0];
                    const d = Math.hypot(lm[8].x - lm[0].x, lm[8].y - lm[0].y); 
                    let target = (d - 0.2) * 3.3; 
                    handOpenFactor += (Math.max(0, Math.min(1, target)) - handOpenFactor) * 0.1;
                    
                    const status = document.getElementById('status-text');
                    if(handOpenFactor < 0.35) status.innerText = "STATE: TREE (FIST)";
                    else status.innerText = "STATE: BURST (OPEN)";
                    
                    const pinch = Math.hypot(lm[4].x-lm[8].x, lm[4].y-lm[8].y);
                    if(pinch < 0.05) status.innerText = "STATE: VIEW PHOTO";
                } else if(!isMouseMode) {
                    handOpenFactor += (0 - handOpenFactor) * 0.05;
                    document.getElementById('status-text').innerText = "WAITING FOR HAND...";
                }
            });

            const cam = new Camera(document.getElementById('input_video'), {
                onFrame: async () => { await hands.send({image: document.getElementById('input_video')}); },
                width: 320, height: 240
            });
            
            const timer = setTimeout(() => {
                console.log("Camera timeout, switching to mouse.");
                switchToMouseMode();
            }, 3000);

            cam.start().then(()=>{ clearTimeout(timer); }).catch(() => {
                clearTimeout(timer);
                switchToMouseMode();
            });
        }

        // ================= åŠ¨ç”»å¾ªç¯ =================
        const dummy = new THREE.Object3D();

        function animate() {
            requestAnimationFrame(animate);
            const time = Date.now() * 0.001;

            if(goldParticles) {
                goldParticles.material.uniforms.uTime.value = time;
                goldParticles.material.uniforms.uFactor.value = handOpenFactor;
                goldParticles.material.uniforms.uIsPhoto.value += ((isPhotoMode?1:0) - goldParticles.material.uniforms.uIsPhoto.value)*0.1;
            }

            // æ›´æ–°ç¤¼ç‰©ç›’ä½ç½® (InstancedMesh)
            if(itemParticles) {
                const offsets = itemParticles.userData.offsets;
                for(let i=0; i<ITEM_COUNT; i++) {
                    const off = offsets[i];
                    // ç®€å•çš„æ—‹è½¬é€»è¾‘
                    const angle = time * 0.2 * off.speed + off.y * 0.01;
                    const r = Math.sqrt(off.x*off.x + off.z*off.z); // åŠå¾„
                    
                    // æ ¹æ®æ‰‹åŠ¿æ‰©æ•£
                    const spread = 1.0 + handOpenFactor * 2.0; // æ‰©æ•£å€æ•°
                    
                    dummy.position.set(
                        Math.cos(angle) * r * spread,
                        off.y + Math.sin(time + i)*5,
                        Math.sin(angle) * r * spread
                    );
                    dummy.rotation.set(time, time, 0);
                    dummy.updateMatrix();
                    itemParticles.setMatrixAt(i, dummy.matrix);
                }
                itemParticles.instanceMatrix.needsUpdate = true;
            }

            // æ›´æ–°ç…§ç‰‡ç²’å­
            photoParticleGroups.forEach(sys => {
                sys.rotation.y += sys.userData.speed;
                // ç®€å•çš„å‘¼å¸
                const s = 1.0 + handOpenFactor * 2.0;
                sys.scale.set(s,s,s);
            });

            if(photoMesh) {
                const targetOp = isPhotoMode ? 1.0 : 0.0;
                photoMesh.material.opacity += (targetOp - photoMesh.material.opacity) * 0.1;
                if(isPhotoMode) {
                    photoMesh.position.y = Math.sin(time)*1.0; 
                    photoMesh.rotation.y = Math.sin(time*0.5)*0.1;
                }
            }

            renderer.render(scene, camera);
        }

        // å¯åŠ¨é¡ºåºä¼˜åŒ–ï¼šå…ˆæ¸²æŸ“ï¼Œå†åŠ è½½é€»è¾‘
        initThree();
        animate(); // ç«‹å³å¯åŠ¨æ¸²æŸ“å¾ªç¯ï¼Œé˜²æ­¢é»‘å±
        
        // å»¶è¿Ÿå¯åŠ¨é‡é€»è¾‘
        setTimeout(() => {
            initMediaPipe();
            loadGallery();
        }, 100);

    </script>
</body>
</html>