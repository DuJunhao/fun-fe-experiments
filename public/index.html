<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D ç²’å­äº’åŠ¨ç›¸å†Œ</title>
    <style>
        body {
            margin: 0; overflow: hidden; background-color: #050505;
            font-family: 'Helvetica Neue', Arial, sans-serif; user-select: none;
        }
        #canvas-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; }

        /* UI é¢æ¿ */
        #ui-panel {
            position: absolute; top: 20px; left: 20px; width: 200px;
            background: rgba(20, 20, 20, 0.7); backdrop-filter: blur(10px);
            padding: 15px; border-radius: 12px; color: #fff; z-index: 10;
            display: flex; flex-direction: column; gap: 12px;
            border: 1px solid rgba(255,255,255,0.05); transition: opacity 0.3s;
        }
        .ui-group { display: flex; flex-direction: column; gap: 8px; }
        label { font-size: 11px; color: #888; letter-spacing: 1px; font-weight: bold;}
        .shape-btn {
            background: rgba(255,255,255,0.05); border: 1px solid transparent; color: #ddd;
            padding: 8px; border-radius: 6px; cursor: pointer; transition: all 0.2s;
            text-align: left; font-size: 14px;
        }
        .shape-btn:hover { background: rgba(255,255,255,0.15); }
        .shape-btn.active { background: rgba(0, 123, 255, 0.2); border-color: #007bff; color: #fff; }
        input[type="color"] { width: 100%; height: 30px; border: none; border-radius: 4px; background: none; cursor: pointer;}

        /* åº•éƒ¨ç…§ç‰‡æ  */
        #gallery-container {
            position: absolute; bottom: 0; left: 0; width: 100%; height: 90px;
            background: linear-gradient(to top, rgba(0,0,0,0.9), transparent);
            display: flex; align-items: center; overflow-x: auto; padding: 0 10px; z-index: 10;
        }
        .gallery-item {
            height: 60px; width: 60px; object-fit: cover; margin-right: 10px;
            border-radius: 6px; cursor: pointer; border: 2px solid rgba(255,255,255,0.1);
            transition: all 0.3s; flex-shrink: 0; opacity: 0.6;
        }
        .gallery-item:hover { transform: scale(1.1); opacity: 1; }
        .gallery-item.selected { border-color: #00ffff; opacity: 1; box-shadow: 0 0 8px #00ffff; }

        /* çŠ¶æ€æŒ‡ç¤ºå™¨ */
        #status-indicator {
            position: absolute; top: 20px; right: 20px; padding: 6px 12px; border-radius: 20px;
            font-size: 12px; z-index: 10; backdrop-filter: blur(5px); display: flex; align-items: center; gap: 6px;
        }
        .status-mouse { background: rgba(255, 165, 0, 0.2); color: #ffa500; border: 1px solid rgba(255, 165, 0, 0.3); }
        .status-cam { background: rgba(0, 255, 127, 0.2); color: #00ff7f; border: 1px solid rgba(0, 255, 127, 0.3); }
        .dot { width: 6px; height: 6px; border-radius: 50%; background: currentColor; }
        .input_video { display: none; }
        #overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: #000; z-index: 100;
            display: flex; justify-content: center; align-items: center; color: #666; transition: opacity 0.5s;
        }
    </style>
</head>
<body>

    <div id="overlay">ç³»ç»Ÿåˆå§‹åŒ–ä¸­...</div>
    <div id="status-indicator" style="display:none;"><div class="dot"></div><span id="status-text">Detecting...</span></div>
    <div id="canvas-container"></div>

    <div id="ui-panel">
        <div class="ui-group">
            <label>SHAPE MODE</label>
            <button class="shape-btn active" data-shape="heart">â¤ï¸ çˆ±å¿ƒ (Heart)</button>
            <button class="shape-btn" data-shape="tree">ğŸ„ åœ£è¯æ ‘ (Tree)</button>
            <button class="shape-btn" data-shape="flower">ğŸŒ¸ èŠ±æœµ (Flower)</button>
        </div>
        <div class="ui-group">
             <label>COLOR</label>
            <input type="color" id="color-picker" value="#ff0055">
        </div>
    </div>
    
    <div id="gallery-container">
        <div style="color:#666;width:100%;text-align:center;font-size:12px;">Loading Photos...</div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/math/MeshSurfaceSampler.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <script>
        let scene, camera, renderer, particleSystem, uniforms;
        let photoMesh, textureLoader; // ç”¨äºæ˜¾ç¤ºç…§ç‰‡çš„ç½‘æ ¼å’ŒåŠ è½½å™¨
        
        // æ ¸å¿ƒçŠ¶æ€
        let handOpenFactor = 0; // 0=èšæ‹¢, 1=æ‰©æ•£
        let isMouseMode = false;
        let isPhotoMode = false; // å½“å‰æ˜¯å¦åœ¨æŸ¥çœ‹ç…§ç‰‡
        const PARTICLE_COUNT = 30000;
        const videoElement = document.createElement('video');
        videoElement.classList.add('input_video');
        
        // ==========================================
        // 1. Three.js åˆå§‹åŒ–
        // ==========================================
        function initThree() {
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x050505, 0.002);
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 80;
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.setClearColor(0x050505);
            document.getElementById('canvas-container').appendChild(renderer.domElement);
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });

            // åˆå§‹åŒ–ç…§ç‰‡æ˜¾ç¤ºå¹³é¢
            textureLoader = new THREE.TextureLoader();
            // å…è®¸è·¨åŸŸåŠ è½½å›¾ç‰‡
            textureLoader.crossOrigin = "Anonymous";
            const photoGeo = new THREE.PlaneGeometry(1, 1); // åˆå§‹å¤§å°1x1ï¼Œåé¢åŠ¨æ€è°ƒæ•´
            const photoMat = new THREE.MeshBasicMaterial({ 
                color: 0xffffff, side: THREE.DoubleSide, transparent: true, opacity: 0 
            });
            photoMesh = new THREE.Mesh(photoGeo, photoMat);
            scene.add(photoMesh);
        }

        // ==========================================
        // 2. é¼ æ ‡äº¤äº’
        // ==========================================
        document.addEventListener('mousemove', (e) => {
            if (isMouseMode) {
                // é¼ æ ‡ä½ç½®æ§åˆ¶å¼ å¼€ç¨‹åº¦ (ä¸Š=æ‰©æ•£, ä¸‹=èšæ‹¢)
                handOpenFactor = 1.0 - (e.clientY / window.innerHeight);
                // é¼ æ ‡å·¦å³æ§åˆ¶ç¼“æ…¢æ—‹è½¬
                if(particleSystem) {
                    particleSystem.rotation.y = (e.clientX / window.innerWidth - 0.5) * 0.5;
                }
            }
        });

        // ==========================================
        // 3. ç²’å­ç³»ç»Ÿ (Shader)
        // ==========================================
        const vertexShader = `
            uniform float uTime;
            uniform float uHandOpenFactor;
            uniform float uIsPhotoMode; // æ–°å¢ï¼šæ˜¯å¦åœ¨ç…§ç‰‡æ¨¡å¼
            attribute vec3 aTargetPosition;
            attribute vec3 aRandomOffset;
            varying float vAlpha;

            void main() {
                vec3 target = aTargetPosition;
                // æ‰©æ•£çŠ¶æ€ï¼šå‘å¤–çˆ†ç‚¸ + å™ªç‚¹ç§»åŠ¨
                vec3 diffusedState = aTargetPosition + normalize(aRandomOffset) * (70.0 + sin(uTime * 1.5 + aRandomOffset.x) * 15.0);
                
                // æ ¸å¿ƒé€»è¾‘ï¼šå¦‚æœåœ¨ç…§ç‰‡æ¨¡å¼ï¼Œå¼ºåˆ¶å¢åŠ æ‰©æ•£å€¾å‘ï¼Œè®©ç²’å­æ•£å¼€è®©å‡ºè§†é‡
                float effectiveOpenFactor = mix(uHandOpenFactor, 1.0, uIsPhotoMode * 0.7);

                vec3 finalPosition = mix(target, diffusedState, effectiveOpenFactor);
                
                // å‘¼å¸åŠ¨ç”»
                float scale = 1.0 + effectiveOpenFactor * 0.3;
                vec4 mvPosition = modelViewMatrix * vec4(finalPosition * scale, 1.0);
                gl_Position = projectionMatrix * mvPosition;
                
                // ç²’å­å¤§å°éšè·ç¦»å˜åŒ–
                gl_PointSize = (2.0 * scale) * (300.0 / -mvPosition.z);
                vAlpha = 1.0 - smoothstep(0.0, 1.0, effectiveOpenFactor * length(aRandomOffset)*0.4);
            }
        `;

        const fragmentShader = `
            uniform vec3 uColor;
            varying float vAlpha;
            void main() {
                vec2 coord = gl_PointCoord - vec2(0.5);
                if (length(coord) > 0.5) discard;
                // ç®€å•çš„è¾‰å…‰èŠ¯
                float strength = 1.0 - length(coord) * 2.0;
                gl_FragColor = vec4(uColor, strength * vAlpha);
            }
        `;

        function createParticleSystem(shapeName) {
            if (particleSystem) scene.remove(particleSystem);
            // åˆ‡æ¢å›å½¢çŠ¶æ¨¡å¼æ—¶ï¼Œéšè—ç…§ç‰‡
            isPhotoMode = false;

            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(PARTICLE_COUNT * 3);
            const targetPositions = new Float32Array(PARTICLE_COUNT * 3);
            const randomOffsets = new Float32Array(PARTICLE_COUNT * 3);

            const shapePoints = generateShapePoints(shapeName, PARTICLE_COUNT);

            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const i3 = i * 3;
                positions[i3]=0; positions[i3+1]=0; positions[i3+2]=0;
                targetPositions[i3] = shapePoints[i].x;
                targetPositions[i3+1] = shapePoints[i].y;
                targetPositions[i3+2] = shapePoints[i].z;
                randomOffsets[i3] = (Math.random()-0.5)*2; 
                randomOffsets[i3+1] = (Math.random()-0.5)*2; 
                randomOffsets[i3+2] = (Math.random()-0.5)*2;
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('aTargetPosition', new THREE.BufferAttribute(targetPositions, 3));
            geometry.setAttribute('aRandomOffset', new THREE.BufferAttribute(randomOffsets, 3));

            const colorHex = document.getElementById('color-picker').value;
            
            uniforms = {
                uTime: { value: 0 },
                uHandOpenFactor: { value: 0 },
                uIsPhotoMode: { value: 0 }, // 0=å½¢çŠ¶, 1=ç…§ç‰‡
                uColor: { value: new THREE.Color(colorHex) }
            };

            const material = new THREE.ShaderMaterial({
                uniforms: uniforms,
                vertexShader: vertexShader,
                fragmentShader: fragmentShader,
                transparent: true, depthWrite: false, blending: THREE.AdditiveBlending
            });
            particleSystem = new THREE.Points(geometry, material);
            scene.add(particleSystem);
        }

        // ==========================================
        // 4. å½¢çŠ¶ç”Ÿæˆ (æ–°å¢åœ£è¯æ ‘)
        // ==========================================
        function sampleGeometry(geometry, count) {
            const material = new THREE.MeshBasicMaterial();
            const mesh = new THREE.Mesh(geometry, material);
            const sampler = new THREE.MeshSurfaceSampler(mesh).build();
            const points = []; const temp = new THREE.Vector3();
            for(let i=0; i<count; i++){ sampler.sample(temp); points.push(temp.clone()); }
            return points;
        }

        function generateShapePoints(shape, count) {
            const points = []; let v = new THREE.Vector3();
            if (shape === 'heart') {
                for(let i=0; i<count; i++){
                    let t = Math.random()*Math.PI*2, x = 16*Math.pow(Math.sin(t),3), y = 13*Math.cos(t)-5*Math.cos(2*t)-2*Math.cos(3*t)-Math.cos(4*t), z = (Math.random()-0.5)*15;
                    v.set(x,y,z).multiplyScalar(1.8); points.push(v.clone());
                }
            } else if (shape === 'tree') {
                // åœ£è¯æ ‘ï¼šèºæ—‹åœ†é”¥ä½“
                for(let i=0; i<count; i++){
                    let h = i / count; // é«˜åº¦ 0-1
                    let angle = h * Math.PI * 25; // èºæ—‹åœˆæ•°
                    let radius = (1 - h) * 25; // åº•éƒ¨å®½ï¼Œé¡¶éƒ¨å°–
                    let x = Math.cos(angle) * radius + (Math.random()-0.5)*2;
                    let z = Math.sin(angle) * radius + (Math.random()-0.5)*2;
                    let y = (h - 0.5) * 60; // é«˜åº¦æ‹‰ä¼¸
                    // æ ‘åº•åŠ ä¸€ç‚¹éšæœºæ•£è½
                    if (h < 0.1) { x*=1.5; z*=1.5; }
                    v.set(x, y, z); points.push(v.clone());
                }
            } else if (shape === 'flower') {
                const geo = new THREE.TorusKnotGeometry(18, 6, 150, 20, 5, 8);
                return sampleGeometry(geo, count);
            }
            return points;
        }

        // ==========================================
        // 5. ç…§ç‰‡åŠ è½½ä¸æ˜¾ç¤ºé€»è¾‘
        // ==========================================
        function showPhoto(url) {
            isPhotoMode = true;
            // å–æ¶ˆå½¢çŠ¶æŒ‰é’®çš„é€‰ä¸­çŠ¶æ€
            document.querySelectorAll('.shape-btn').forEach(b => b.classList.remove('active'));
            
            // åŠ è½½çº¹ç†
            // æ·»åŠ æ—¶é—´æˆ³é˜²ç¼“å­˜
            textureLoader.load(url + "?t=" + Date.now(), (texture) => {
                // æ ¹æ®å›¾ç‰‡å®½é«˜æ¯”è°ƒæ•´å¹³é¢ç½‘æ ¼å½¢çŠ¶
                const aspect = texture.image.width / texture.image.height;
                // åŸºç¡€é«˜åº¦è®¾ä¸º 35 ä¸ªå•ä½
                const baseHeight = 35;
                photoMesh.geometry.dispose();
                photoMesh.geometry = new THREE.PlaneGeometry(baseHeight * aspect, baseHeight);
                
                photoMesh.material.map = texture;
                photoMesh.material.needsUpdate = true;
                // æ¸æ˜¾åŠ¨ç”»åœ¨ animate ä¸­å¤„ç†
            });
        }

        // ==========================================
        // 6. åº”ç”¨é€»è¾‘æ§åˆ¶
        // ==========================================
        function setMode(mode) {
            const ind = document.getElementById('status-indicator');
            const txt = document.getElementById('status-text');
            ind.style.display = 'flex';
            if (mode === 'MOUSE') {
                isMouseMode = true; ind.className = 'status-mouse'; txt.innerText = 'Mouse Mode';
            } else {
                isMouseMode = false; ind.className = 'status-cam'; txt.innerText = 'Camera Mode';
            }
            setTimeout(() => { document.getElementById('overlay').style.opacity = '0'; setTimeout(()=>document.getElementById('overlay').remove(), 500); }, 500);
        }

        async function initApp() {
            initThree();
            createParticleSystem('heart'); // é»˜è®¤å½¢çŠ¶

            // UIäº‹ä»¶
            document.querySelectorAll('.shape-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    document.querySelectorAll('.shape-btn').forEach(b=>b.classList.remove('active'));
                    e.target.classList.add('active');
                    createParticleSystem(e.target.dataset.shape);
                });
            });
            document.getElementById('color-picker').addEventListener('input', (e)=>{
                if(uniforms) uniforms.uColor.value.set(e.target.value);
            });

            // åŠ è½½ç”»å»Š
            loadGallery();

            // MediaPipeå¯åŠ¨
            const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
            hands.setOptions({maxNumHands: 1, modelComplexity: 0, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5});
            hands.onResults((results) => {
                if (!isMouseMode && results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                    const lm = results.multiHandLandmarks[0];
                    const d1 = Math.hypot(lm[8].x - lm[0].x, lm[8].y - lm[0].y);
                    const d2 = Math.hypot(lm[20].x - lm[0].x, lm[20].y - lm[0].y);
                    let target = ((d1 + d2) / 2 - 0.2) * 4.0;
                    handOpenFactor += (Math.max(0, Math.min(1, target)) - handOpenFactor) * 0.1;
                } else if (!isMouseMode) {
                    handOpenFactor += (0 - handOpenFactor) * 0.05; // æ— æ‰‹è‡ªåŠ¨èšæ‹¢
                }
            });
            const cameraObj = new Camera(videoElement, { onFrame: async () => { await hands.send({image: videoElement}); }, width: 320, height: 240 });
            const timeoutId = setTimeout(() => { console.log("Camera timeout."); setMode('MOUSE'); }, 3000);
            cameraObj.start().then(() => { clearTimeout(timeoutId); setMode('CAMERA'); }).catch(() => { clearTimeout(timeoutId); setMode('MOUSE'); });
        }

        async function loadGallery() {
            const container = document.getElementById('gallery-container');
            try {
                const res = await fetch('/api/images');
                const images = await res.json();
                container.innerHTML = '';
                if(images.length === 0) { container.innerHTML = '<div style="color:#666;margin:auto">No Photos</div>'; return; }
                images.forEach((data) => {
                    const el = document.createElement('img');
                    el.src = data.url; el.className = 'gallery-item';
                    el.onclick = () => {
                        document.querySelectorAll('.gallery-item').forEach(e=>e.classList.remove('selected'));
                        el.classList.add('selected');
                        showPhoto(data.url); // ç‚¹å‡»åŠ è½½ç…§ç‰‡åˆ°3Dåœºæ™¯
                    };
                    container.appendChild(el);
                });
            } catch(e) { container.innerHTML = '<div style="color:red;margin:auto">Gallery Offline</div>'; }
        }

        // ä¸»å¾ªç¯
        function animate() {
            requestAnimationFrame(animate);
            if (uniforms) {
                uniforms.uTime.value += 0.02;
                uniforms.uHandOpenFactor.value = handOpenFactor;
                // å¹³æ»‘è¿‡æ¸¡ç…§ç‰‡æ¨¡å¼çŠ¶æ€
                uniforms.uIsPhotoMode.value += ((isPhotoMode ? 1.0 : 0.0) - uniforms.uIsPhotoMode.value) * 0.1;
                if (!isMouseMode) particleSystem.rotation.y += 0.001; // è‡ªåŠ¨æ…¢æ—‹
            }
            // ç…§ç‰‡æ¸æ˜¾æ¸éšåŠ¨ç”»
            if (photoMesh) {
                const targetOpacity = isPhotoMode ? 1.0 : 0.0;
                photoMesh.material.opacity += (targetOpacity - photoMesh.material.opacity) * 0.1;
                // ç¨å¾®è®©ç…§ç‰‡æµ®åŠ¨ä¸€ç‚¹
                if(isPhotoMode) photoMesh.position.y = Math.sin(uniforms.uTime.value) * 0.5;
            }
            renderer.render(scene, camera);
        }

        initApp();
        animate();
    </script>
</body>
</html>