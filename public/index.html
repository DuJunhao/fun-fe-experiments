<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Golden Memories AR</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Arial', sans-serif; user-select: none; }
        #canvas-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; }

        /* UI é¢æ¿ */
        #ui-panel {
            position: absolute; top: 20px; left: 20px; width: 220px;
            background: linear-gradient(135deg, rgba(10,10,10,0.8), rgba(30,30,30,0.9));
            backdrop-filter: blur(12px);
            padding: 20px; border-radius: 8px; color: #d4af37; z-index: 10;
            border: 1px solid rgba(212, 175, 55, 0.2);
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
        }
        .ui-header { font-size: 10px; letter-spacing: 3px; color: #888; margin-bottom: 15px; font-weight: 800; border-bottom: 1px solid #333; padding-bottom: 5px; }
        .status-text { font-size: 16px; color: #fff; text-shadow: 0 0 10px rgba(212, 175, 55, 0.6); font-weight: bold; margin-bottom: 20px; }
        .hint-row { display: flex; align-items: center; gap: 10px; margin-bottom: 8px; font-size: 12px; color: #aaa; }
        .icon { width: 16px; text-align: center; }

        /* åº•éƒ¨ç…§ç‰‡æ  */
        #gallery-container {
            position: absolute; bottom: 0; left: 0; width: 100%; height: 120px;
            background: linear-gradient(to top, #000 30%, transparent);
            display: flex; align-items: center; overflow-x: auto; padding: 0 30px; z-index: 10; gap: 20px;
        }
        #gallery-container::-webkit-scrollbar { display: none; }
        .gallery-item {
            height: 70px; width: 70px; object-fit: cover;
            border-radius: 50%; /* åœ†å½¢ */
            cursor: pointer; border: 2px solid #444;
            transition: all 0.4s cubic-bezier(0.34, 1.56, 0.64, 1); /* å¼¹æ€§åŠ¨ç”» */
            flex-shrink: 0; filter: grayscale(100%); opacity: 0.6;
        }
        .gallery-item:hover { transform: scale(1.2) translateY(-10px); filter: grayscale(0%); opacity: 1; border-color: #fff; }
        .gallery-item.selected { 
            border-color: #d4af37; opacity: 1; filter: grayscale(0%);
            box-shadow: 0 0 20px rgba(212, 175, 55, 0.5); 
            transform: scale(1.3) translateY(-15px); 
        }
        
        #loading-text { color: #666; font-size: 12px; width: 100%; text-align: center; letter-spacing: 1px; }
        video { display: none; }
    </style>
</head>
<body>

    <div id="ui-panel">
        <div class="ui-header">SYSTEM STATUS</div>
        <div id="status-text" class="status-text">INITIALIZING...</div>
        
        <div class="ui-header">CONTROLS</div>
        <div id="ctrl-hint-cam">
            <div class="hint-row"><span class="icon">âœŠ</span> æ¡æ‹³èšåˆ (Tree)</div>
            <div class="hint-row"><span class="icon">ğŸ–</span> å¼ æ‰‹çˆ†å‘ (Burst)</div>
            <div class="hint-row"><span class="icon">ğŸ‘Œ</span> æåˆç¼©æ”¾ (Zoom)</div>
        </div>
        <div id="ctrl-hint-mouse" style="display:none">
            <div class="hint-row"><span class="icon">â†•ï¸</span> ä¸Šä¸‹èšæ•£</div>
            <div class="hint-row"><span class="icon">â†”ï¸</span> å·¦å³æ—‹è½¬</div>
        </div>
    </div>

    <div id="canvas-container"></div>
    <video id="input_video"></video>

    <div id="gallery-container">
        <div id="loading-text">æ­£åœ¨ä»äº‘ç«¯åŒæ­¥æ•°æ®...</div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <script>
        // ================= å…¨å±€å˜é‡ =================
        let scene, camera, renderer;
        let goldParticles, giftParticles; // ç²’å­ç³»ç»Ÿ
        let photoCards = []; // å­˜æ”¾æ‚¬æµ®ç…§ç‰‡ Mesh çš„æ•°ç»„
        let activePhotoIndex = -1; // å½“å‰é€‰ä¸­çš„ç…§ç‰‡ç´¢å¼•
        
        // äº¤äº’çŠ¶æ€
        let handOpenFactor = 0; // 0=æ ‘(èš), 1=ç‚¸(æ•£)
        let isMouseMode = false;
        let pinchScale = 1.0; // æåˆç¼©æ”¾ç³»æ•°
        
        const GOLD_COUNT = 35000; // æ›´å¤šç²’å­ï¼Œæ›´å¯†
        const GIFT_COUNT = 200; 

        // ================= è¾…åŠ©ï¼šç¨‹åºåŒ–ç”Ÿæˆçº¹ç† =================
        function createGlowTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 64; canvas.height = 64;
            const ctx = canvas.getContext('2d');
            const g = ctx.createRadialGradient(32, 32, 0, 32, 32, 32);
            g.addColorStop(0, 'rgba(255, 255, 255, 1)');
            g.addColorStop(0.2, 'rgba(255, 215, 0, 0.8)'); // é‡‘è‰²æ ¸å¿ƒ
            g.addColorStop(0.5, 'rgba(255, 140, 0, 0.2)'); // æ©™è‰²å…‰æ™•
            g.addColorStop(1, 'rgba(0, 0, 0, 0)');
            ctx.fillStyle = g;
            ctx.fillRect(0, 0, 64, 64);
            return new THREE.CanvasTexture(canvas);
        }

        // ================= Three.js åˆå§‹åŒ– =================
        function initThree() {
            const container = document.getElementById('canvas-container');
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x000000, 0.001);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);
            camera.position.z = 100;

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.outputEncoding = THREE.sRGBEncoding;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            container.appendChild(renderer.domElement);

            const glowTex = createGlowTexture();
            
            // --- 1. å¥¢åé‡‘æ ‘ (ä¸»ä½“) ---
            const goldGeo = new THREE.BufferGeometry();
            const pos = [], target = [], offset = [], color = [];
            const c1 = new THREE.Color(0xFFD700); // é‡‘
            const c2 = new THREE.Color(0xFFFFFF); // ç™½
            const c3 = new THREE.Color(0xFF4500); // çº¢

            for(let i=0; i<GOLD_COUNT; i++) {
                pos.push(0,0,0);
                // æ ‘å½¢ï¼šæ›´ä¼˜é›…çš„èºæ—‹
                const h = Math.random(); 
                const angle = h * Math.PI * 25; 
                const r = (1 - Math.pow(h, 0.8)) * 45; // åº•éƒ¨å®½ï¼Œé¡¶éƒ¨å°–
                target.push(Math.cos(angle)*r, (h-0.5)*120, Math.sin(angle)*r);
                
                // çˆ†ç‚¸åç§»
                offset.push((Math.random()-0.5)*2, (Math.random()-0.5)*2, (Math.random()-0.5)*2);
                
                // æ··è‰²
                const rnd = Math.random();
                const c = rnd > 0.9 ? c2 : (rnd > 0.8 ? c3 : c1);
                color.push(c.r, c.g, c.b);
            }
            goldGeo.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));
            goldGeo.setAttribute('aTarget', new THREE.Float32BufferAttribute(target, 3));
            goldGeo.setAttribute('aOffset', new THREE.Float32BufferAttribute(offset, 3));
            goldGeo.setAttribute('color', new THREE.Float32BufferAttribute(color, 3));

            const goldMat = new THREE.ShaderMaterial({
                uniforms: {
                    uTime: { value: 0 },
                    uFactor: { value: 0 },
                    uTex: { value: glowTex }
                },
                vertexShader: `
                    uniform float uTime;
                    uniform float uFactor;
                    attribute vec3 aTarget;
                    attribute vec3 aOffset;
                    attribute vec3 color;
                    varying vec3 vColor;
                    void main() {
                        vColor = color;
                        // æ ‘çš„æ—‹è½¬
                        vec3 posTree = aTarget;
                        float ang = uTime * 0.15 + aTarget.y * 0.005;
                        float ca = cos(ang), sa = sin(ang);
                        posTree.x = aTarget.x * ca - aTarget.z * sa;
                        posTree.z = aTarget.x * sa + aTarget.z * ca;

                        // çˆ†ç‚¸
                        vec3 posExp = aTarget + normalize(aOffset) * (150.0 + sin(uTime*2.0+aOffset.x)*30.0);
                        
                        vec3 finalPos = mix(posTree, posExp, uFactor);
                        
                        vec4 mvPosition = modelViewMatrix * vec4(finalPos, 1.0);
                        gl_Position = projectionMatrix * mvPosition;
                        // æ¡æ‹³æ—¶ç²’å­å¤§ï¼Œå¼ å¼€æ—¶ç²’å­å°
                        gl_PointSize = (4.0 * (1.2 - uFactor*0.5)) * (300.0 / -mvPosition.z);
                    }
                `,
                fragmentShader: `
                    uniform sampler2D uTex;
                    varying vec3 vColor;
                    void main() {
                        vec4 tex = texture2D(uTex, gl_PointCoord);
                        if(tex.a < 0.05) discard;
                        gl_FragColor = vec4(vColor * 2.0, tex.a); // äº®åº¦å€å¢
                    }
                `,
                transparent: true, depthWrite: false, blending: THREE.AdditiveBlending
            });
            goldParticles = new THREE.Points(goldGeo, goldMat);
            scene.add(goldParticles);

            // --- 2. ç¤¼ç‰©/ä¿¡å° (æ¼‚æµ®æ–¹å—) ---
            const giftGeo = new THREE.BoxGeometry(2, 2, 2);
            const giftMat = new THREE.MeshBasicMaterial({ color: 0xff3333 });
            giftParticles = new THREE.InstancedMesh(giftGeo, giftMat, GIFT_COUNT);
            const dummy = new THREE.Object3D();
            const giftData = [];
            for(let i=0; i<GIFT_COUNT; i++) {
                const r = 25 + Math.random()*40;
                const theta = Math.random()*Math.PI*2;
                const y = (Math.random()-0.5)*100;
                giftData.push({ r, theta, y, speed: Math.random()*0.5+0.2 });
            }
            giftParticles.userData = { data: giftData };
            scene.add(giftParticles);

            window.addEventListener('resize', onResize);
        }

        function onResize() {
            camera.aspect = window.innerWidth/window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // ================= æ ¸å¿ƒï¼šç…§ç‰‡å¡ç‰‡ç³»ç»Ÿ =================
        
        // åˆ›å»ºå•ä¸ªæ‚¬æµ®ç…§ç‰‡å¡ç‰‡
        function createPhotoCard(texture, index) {
            // æè´¨ï¼šæ­£é¢æ˜¯ç…§ç‰‡ï¼ŒåŠ ä¸ªé‡‘è¾¹
            const mat = new THREE.MeshBasicMaterial({ map: texture, side: THREE.DoubleSide });
            // å‡ ä½•ä½“
            const aspect = texture.image.width / texture.image.height;
            const geo = new THREE.PlaneGeometry(10 * aspect, 10);
            const mesh = new THREE.Mesh(geo, mat);

            // é‡‘è¾¹æ¡† (å­å¯¹è±¡)
            const borderGeo = new THREE.PlaneGeometry(10 * aspect + 0.5, 10 + 0.5);
            const borderMat = new THREE.MeshBasicMaterial({ color: 0xFFD700, side: THREE.BackSide });
            const border = new THREE.Mesh(borderGeo, borderMat);
            border.position.z = -0.1;
            mesh.add(border);

            // åˆå§‹éšæœºä½ç½® (å›´ç»•æ ‘)
            const angle = (index / 5) * Math.PI * 2; // åˆ†æ•£å¼€
            mesh.userData = {
                id: index,
                baseAngle: angle,
                baseY: (Math.random()-0.5) * 60,
                radius: 50 + Math.random() * 20,
                targetScale: 1.0,
                currentScale: 1.0
            };
            
            scene.add(mesh);
            photoCards.push(mesh);
        }

        // åŠ è½½ç”»å»Š
        async function loadGallery() {
            const container = document.getElementById('gallery-container');
            const status = document.getElementById('loading-text');
            const texLoader = new THREE.TextureLoader();
            texLoader.crossOrigin = "Anonymous";

            try {
                const res = await fetch('/api/images');
                const images = await res.json();
                container.innerHTML = '';
                
                if(images.length === 0) { status.innerText = "ç›¸å†Œä¸ºç©º"; return; }

                images.forEach((imgData, idx) => {
                    const url = imgData.url + "?t=" + Date.now();
                    
                    // DOM ç¼©ç•¥å›¾
                    const el = document.createElement('img');
                    el.src = url; el.className = 'gallery-item';
                    el.onclick = () => {
                        selectPhoto(idx);
                        document.querySelectorAll('.gallery-item').forEach(e=>e.classList.remove('selected'));
                        el.classList.add('selected');
                    };
                    container.appendChild(el);

                    // 3D æ‚¬æµ®å¡ç‰‡
                    texLoader.load(url, (tex) => {
                        createPhotoCard(tex, idx);
                    });
                });
                status.remove();

            } catch(e) { console.error(e); status.innerText = "åŠ è½½å¤±è´¥"; }
        }

        // é€‰ä¸­ç…§ç‰‡é€»è¾‘
        function selectPhoto(index) {
            activePhotoIndex = index;
            // é‡ç½®æåˆç¼©æ”¾
            pinchScale = 1.0; 
        }

        // ================= äº¤äº’æ§åˆ¶ =================
        function initMediaPipe() {
            const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
            hands.setOptions({maxNumHands: 1, modelComplexity: 0});
            
            hands.onResults(results => {
                if(results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                    isMouseMode = false;
                    const lm = results.multiHandLandmarks[0];
                    
                    // 1. å¼ åˆæ£€æµ‹ (Tree vs Burst)
                    const palmDist = Math.hypot(lm[8].x - lm[0].x, lm[8].y - lm[0].y);
                    let targetFactor = (palmDist - 0.2) * 3.5; 
                    handOpenFactor += (Math.max(0, Math.min(1, targetFactor)) - handOpenFactor) * 0.1;
                    
                    const status = document.getElementById('status-text');
                    if(handOpenFactor < 0.4) status.innerText = "MODE: TREE (FIST)";
                    else status.innerText = "MODE: EXPLODE (OPEN)";

                    // 2. æåˆç¼©æ”¾æ£€æµ‹ (Pinch Zoom)
                    const pinchDist = Math.hypot(lm[4].x - lm[8].x, lm[4].y - lm[8].y);
                    
                    // å¦‚æœæ­£åœ¨æåˆ (è·ç¦»å°äº 0.05)
                    if (activePhotoIndex !== -1) {
                        // æ˜ å°„é€»è¾‘ï¼šæåˆè·ç¦» 0.02~0.15 æ˜ å°„åˆ° ç¼©æ”¾ 0.5~3.0
                        // ç›´æ¥æ˜ å°„ï¼Œå®ç°åŒå‘ç¼©æ”¾ (æ‹‰å¼€å˜å¤§ï¼Œåˆæ‹¢å˜å°)
                        let targetScale = (pinchDist - 0.02) * 20.0;
                        targetScale = Math.max(0.5, Math.min(3.5, targetScale)); // é™åˆ¶èŒƒå›´
                        
                        // å¹³æ»‘è¿‡æ¸¡
                        pinchScale += (targetScale - pinchScale) * 0.1;
                        
                        // è§†è§‰åé¦ˆ
                        if (pinchDist < 0.15 && pinchDist > 0.02) {
                            status.innerText = `ZOOMING PHOTO`;
                            status.style.color = "#00ffff";
                        } else {
                            status.style.color = "#fff";
                        }
                    }

                } else if(!isMouseMode) {
                    handOpenFactor += (0 - handOpenFactor) * 0.05;
                    document.getElementById('status-text').innerText = "WAITING FOR HAND...";
                }
            });

            const cam = new Camera(document.getElementById('input_video'), {
                onFrame: async () => { await hands.send({image: document.getElementById('input_video')}); },
                width: 320, height: 240
            });
            
            // é™é»˜å¤±è´¥å¤„ç†
            cam.start().catch(() => {
                isMouseMode = true;
                document.getElementById('status-text').innerText = "MOUSE MODE ACTIVE";
                document.getElementById('ctrl-hint-cam').style.display = 'none';
                document.getElementById('ctrl-hint-mouse').style.display = 'block';
                
                document.addEventListener('mousemove', (e) => {
                    handOpenFactor = 1.0 - (e.clientY / window.innerHeight);
                    // é¼ æ ‡æ»šè½®æ¨¡æ‹Ÿç¼©æ”¾
                });
                document.addEventListener('wheel', (e) => {
                    if(activePhotoIndex !== -1) {
                        pinchScale += e.deltaY * -0.002;
                        pinchScale = Math.max(0.5, Math.min(3.5, pinchScale));
                    }
                });
            });
        }

        // ================= åŠ¨ç”»å¾ªç¯ =================
        const dummy = new THREE.Object3D();

        function animate() {
            requestAnimationFrame(animate);
            const time = Date.now() * 0.001;

            // 1. é‡‘æ ‘ç²’å­
            if(goldParticles) {
                goldParticles.material.uniforms.uTime.value = time;
                goldParticles.material.uniforms.uFactor.value = handOpenFactor;
            }

            // 2. ç¤¼ç‰©ç²’å­
            if(giftParticles) {
                const data = giftParticles.userData.data;
                for(let i=0; i<GIFT_COUNT; i++) {
                    const d = data[i];
                    // å›´ç»•ä¸­å¿ƒæ—‹è½¬
                    const angle = time * 0.2 * d.speed + d.y * 0.01;
                    // æ ¹æ®æ‰‹åŠ¿æ‰©æ•£
                    const spread = 1.0 + handOpenFactor * 2.0;
                    
                    const x = Math.cos(angle) * d.r * spread;
                    const z = Math.sin(angle) * d.r * spread;
                    const y = d.y + Math.sin(time + i)*5;

                    dummy.position.set(x, y, z);
                    dummy.rotation.set(time, time, 0);
                    dummy.updateMatrix();
                    giftParticles.setMatrixAt(i, dummy.matrix);
                }
                giftParticles.instanceMatrix.needsUpdate = true;
            }

            // 3. ç…§ç‰‡å¡ç‰‡åŠ¨ç”» (æ ¸å¿ƒäº¤äº’)
            photoCards.forEach((mesh, i) => {
                const data = mesh.userData;
                
                if (i === activePhotoIndex) {
                    // --- é€‰ä¸­çŠ¶æ€ ---
                    // é£åˆ°å±å¹•æ­£å‰æ–¹ (0, 0, 80)
                    const targetPos = new THREE.Vector3(0, 0, 80);
                    // åªæœ‰é€‰ä¸­æ—¶æ‰åº”ç”¨æåˆç¼©æ”¾
                    const targetScale = pinchScale; 
                    
                    // å¹³æ»‘ç§»åŠ¨ (Lerp)
                    mesh.position.lerp(targetPos, 0.1);
                    // å¹³æ»‘ç¼©æ”¾
                    mesh.scale.x += (targetScale - mesh.scale.x) * 0.1;
                    mesh.scale.y += (targetScale - mesh.scale.y) * 0.1;
                    mesh.scale.z += (targetScale - mesh.scale.z) * 0.1;
                    
                    // æ­£å¯¹ç›¸æœº
                    mesh.lookAt(camera.position);
                    
                    // ç¡®ä¿é€‰ä¸­ç…§ç‰‡åœ¨æœ€å‰é¢
                    mesh.renderOrder = 999;
                    
                } else {
                    // --- å¾…æœºçŠ¶æ€ ---
                    // åœ¨æ ‘å‘¨å›´è½¨é“é£è¡Œ
                    const angle = data.baseAngle + time * 0.1;
                    const spread = 1.0 + handOpenFactor * 1.5; // éšæ‰‹åŠ¿æ‰©æ•£
                    
                    const tx = Math.cos(angle) * data.radius * spread;
                    const tz = Math.sin(angle) * data.radius * spread;
                    const ty = data.baseY + Math.sin(time + i)*2;

                    mesh.position.x += (tx - mesh.position.x) * 0.05;
                    mesh.position.y += (ty - mesh.position.y) * 0.05;
                    mesh.position.z += (tz - mesh.position.z) * 0.05;
                    
                    // æ¢å¤é»˜è®¤å¤§å°
                    mesh.scale.setScalar(1.0);
                    
                    // é¢å‘ä¸­å¿ƒæˆ–ç›¸æœº
                    mesh.lookAt(0,0,0);
                    mesh.renderOrder = 0;
                }
            });

            renderer.render(scene, camera);
        }

        initThree();
        animate(); // ç«‹å³å¯åŠ¨é˜²é»‘å±
        // å»¶æ—¶åŠ è½½é€»è¾‘
        setTimeout(() => {
            initMediaPipe();
            loadGallery();
        }, 100);

    </script>
</body>
</html>