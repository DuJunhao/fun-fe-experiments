<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å¥¢åæµé‡‘åœ£è¯æ ‘ AR</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: sans-serif; user-select: none; }
        #canvas-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; }

        /* UI é¢æ¿ */
        #ui-panel {
            position: absolute; top: 20px; left: 20px; width: 180px;
            background: rgba(10, 10, 10, 0.6); backdrop-filter: blur(8px);
            padding: 15px; border-radius: 8px; color: #d4af37; z-index: 10;
            border: 1px solid rgba(212, 175, 55, 0.3);
            box-shadow: 0 0 20px rgba(212, 175, 55, 0.1);
        }
        .ui-label { font-size: 10px; letter-spacing: 2px; color: #888; margin-bottom: 8px; font-weight: bold; }
        .status-text { font-size: 14px; color: #fff; text-shadow: 0 0 5px gold; }

        /* åº•éƒ¨ç…§ç‰‡æ  */
        #gallery-container {
            position: absolute; bottom: 0; left: 0; width: 100%; height: 110px;
            background: linear-gradient(to top, #000, transparent);
            display: flex; align-items: center; overflow-x: auto; padding: 0 20px; z-index: 10; gap: 15px;
        }
        .gallery-item {
            height: 70px; width: 70px; object-fit: cover;
            border-radius: 4px; cursor: pointer; border: 1px solid #444;
            transition: all 0.3s; flex-shrink: 0; opacity: 0.6;
        }
        .gallery-item:hover { transform: scale(1.1); opacity: 1; border-color: gold; }
        .gallery-item.selected { border-color: gold; opacity: 1; box-shadow: 0 0 15px gold; transform: scale(1.1); }
        
        #loading-text { color: #888; font-size: 12px; width: 100%; text-align: center; }
        
        video { display: none; }
    </style>
</head>
<body>

    <div id="ui-panel">
        <div class="ui-label">STATUS</div>
        <div id="status-text" class="status-text">INITIALIZING...</div>
        <div class="ui-label" style="margin-top:15px">GESTURES</div>
        <div style="font-size:12px; color:#aaa;">âœŠ æ¡æ‹³: èšåˆæˆæ ‘</div>
        <div style="font-size:12px; color:#aaa;">ğŸ– å¼ å¼€: é‡‘ç²‰çˆ†ç‚¸</div>
        <div style="font-size:12px; color:#aaa;">ğŸ‘Œ æåˆ: æŠ“å–ç…§ç‰‡</div>
    </div>

    <div id="canvas-container"></div>
    <video id="input_video"></video>

    <div id="gallery-container">
        <div id="loading-text">æ­£åœ¨ä» Cloud Run è·å–åˆ—è¡¨...</div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <script>
        // --- ç´ æ Base64 (é‡‘å…‰ã€ç¤¼ç‰©ã€ä¿¡å°) ---
        // ç®€å•çš„åœ†å½¢å…‰æ™•
        const SPARK_TEX = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyJpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMC1jMDYwIDYxLjEzNDc3NywgMjAxMC8wMi8xMi0xNzozMjowMCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNSBNYWNpbnRvc2giIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6NDU4NEEwOUQwN0lDMTFFMzg2MzVEOEYxQjE0OEUwNTYiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6NDU4NEEwOUUwN0lDMTFFMzg2MzVEOEYxQjE0OEUwNTYiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDo0NTg0QTA5QjA3SUMxMUUzODYzNUQ4RjFCMTQ4RTA1NiIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo0NTg0QTA5QzA3SUMxMUUzODYzNUQ4RjFCMTQ4RTA1NiIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/Pp/b/CEAAABESURBVHja7M4xEQAwDAOxuVf6Z4wKbLgwF/B4Z2a9930eP378+PHjx48fP378+PHjx48fP378+PHjx48fP378+PHj/8YCDAD1ZQfR7B8r/QAAAABJRU5ErkJggg==";
        // ç¤¼ç‰©å›¾æ ‡ (ç®€æ˜“)
        const GIFT_TEX = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACACAMAAABiEdAAAAA1BMVEUAAACnej3aAAAASElEQVR4nO3BMQEAAADCoPVPbQ0PoAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADeBCAAAAF09CCwAAAAAElFTkSuQmCC"; 
        // ä¿¡å°å›¾æ ‡ (ç®€æ˜“)
        const ENV_TEX = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACACAMAAABiEdAAAAA1BMVEUAAACnej3aAAAASElEQVR4nO3BMQEAAADCoPVPbQ0PoAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADeBCAAAAF09CCwAAAAAElFTkSuQmCC";

        // ================= å…¨å±€å˜é‡ =================
        let scene, camera, renderer, goldParticles, itemParticles, photoMesh;
        let handOpenFactor = 0; // 0=æ ‘(æ¡æ‹³), 1=çˆ†ç‚¸(å¼ å¼€)
        let isMouseMode = false;
        let isPhotoMode = false;
        
        // ç²’å­æ•°é‡
        const GOLD_COUNT = 25000;
        const ITEM_COUNT = 300; 

        // ================= Three.js åˆå§‹åŒ– =================
        function initThree() {
            const container = document.getElementById('canvas-container');
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x000000, 0.001); // é»‘è‰²è¿·é›¾

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);
            camera.position.z = 100;

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            // å…³é”®ï¼šå¼€å¯ç‰©ç†å…‰ç…§æ„Ÿ
            renderer.outputEncoding = THREE.sRGBEncoding;
            container.appendChild(renderer.domElement);

            // åŠ è½½çº¹ç†
            const loader = new THREE.TextureLoader();
            const sparkTexture = loader.load(SPARK_TEX);
            
            // --- ç³»ç»Ÿ1: é‡‘ç²‰ç²’å­ (ç»„æˆæ ‘çš„ä¸»ä½“) ---
            const goldGeo = new THREE.BufferGeometry();
            const goldPos = new Float32Array(GOLD_COUNT * 3);
            const goldTarget = new Float32Array(GOLD_COUNT * 3);
            const goldOffset = new Float32Array(GOLD_COUNT * 3);
            const goldColor = new Float32Array(GOLD_COUNT * 3);

            for(let i=0; i<GOLD_COUNT; i++) {
                const i3 = i*3;
                goldPos[i3]=0; goldPos[i3+1]=0; goldPos[i3+2]=0;
                
                // æ ‘å½¢ç›®æ ‡ (èºæ—‹åœ†é”¥)
                const h = Math.random(); // 0-1
                const angle = h * Math.PI * 18; 
                const r = (1-h) * 35 + Math.random()*2;
                goldTarget[i3] = Math.cos(angle)*r;
                goldTarget[i3+1] = (h-0.5)*90;
                goldTarget[i3+2] = Math.sin(angle)*r;

                // çˆ†ç‚¸åç§»
                goldOffset[i3] = (Math.random()-0.5)*2;
                goldOffset[i3+1] = (Math.random()-0.5)*2;
                goldOffset[i3+2] = (Math.random()-0.5)*2;

                // é¢œè‰²ï¼šé‡‘è‰²ä¸ºä¸»ï¼Œæ··å…¥å°‘é‡çº¢/ç™½
                const colorType = Math.random();
                const col = new THREE.Color();
                if(colorType > 0.9) col.setHex(0xFFFFFF); // ç™½é’»
                else if(colorType > 0.8) col.setHex(0xFF0000); // çº¢å®çŸ³
                else col.setHex(0xFFD700); // çº¯é‡‘
                
                goldColor[i3] = col.r; goldColor[i3+1] = col.g; goldColor[i3+2] = col.b;
            }
            goldGeo.setAttribute('position', new THREE.BufferAttribute(goldPos, 3));
            goldGeo.setAttribute('aTarget', new THREE.BufferAttribute(goldTarget, 3));
            goldGeo.setAttribute('aOffset', new THREE.BufferAttribute(goldOffset, 3));
            goldGeo.setAttribute('color', new THREE.BufferAttribute(goldColor, 3));

            const goldMat = new THREE.ShaderMaterial({
                uniforms: {
                    uTime: { value: 0 },
                    uFactor: { value: 0 },
                    uTex: { value: sparkTexture },
                    uIsPhoto: { value: 0 }
                },
                vertexShader: `
                    uniform float uTime;
                    uniform float uFactor; // 0=æ ‘, 1=ç‚¸
                    uniform float uIsPhoto;
                    attribute vec3 aTarget;
                    attribute vec3 aOffset;
                    attribute vec3 color;
                    varying vec3 vColor;
                    varying float vAlpha;
                    void main() {
                        vColor = color;
                        // æ ‘å½¢æ€
                        vec3 posTree = aTarget;
                        // åŠ ä¸Šæ—‹è½¬
                        float angle = uTime * 0.2;
                        float ca = cos(angle); float sa = sin(angle);
                        posTree.x = aTarget.x * ca - aTarget.z * sa;
                        posTree.z = aTarget.x * sa + aTarget.z * ca;

                        // çˆ†ç‚¸å½¢æ€
                        vec3 posExp = aTarget + normalize(aOffset) * (80.0 + sin(uTime*3.0+aOffset.x)*10.0);
                        
                        // æœ€ç»ˆæ··åˆ (ç…§ç‰‡æ¨¡å¼æ—¶å¼ºåˆ¶æ•£å¼€)
                        float finalFactor = mix(uFactor, 1.0, uIsPhoto * 0.9);
                        vec3 finalPos = mix(posTree, posExp, finalFactor);
                        
                        vec4 mvPosition = modelViewMatrix * vec4(finalPos, 1.0);
                        gl_Position = projectionMatrix * mvPosition;
                        gl_PointSize = (4.0 * (1.0+finalFactor)) * (300.0 / -mvPosition.z);
                        vAlpha = 1.0;
                    }
                `,
                fragmentShader: `
                    uniform sampler2D uTex;
                    varying vec3 vColor;
                    varying float vAlpha;
                    void main() {
                        vec4 tex = texture2D(uTex, gl_PointCoord);
                        if(tex.a < 0.1) discard;
                        gl_FragColor = vec4(vColor, tex.a * vAlpha);
                    }
                `,
                transparent: true,
                depthWrite: false,
                blending: THREE.AdditiveBlending // å…³é”®ï¼šå‘å…‰å åŠ 
            });
            goldParticles = new THREE.Points(goldGeo, goldMat);
            scene.add(goldParticles);

            // --- ç³»ç»Ÿ2: æ°›å›´æ¼‚æµ®ç‰© (ç¤¼ç‰©ã€ä¿¡å°) ---
            // ä¸ºäº†ç®€åŒ–ï¼Œè¿™é‡Œä¹Ÿç”¨ Pointsï¼Œä½†è®¾ç½®æ›´å¤§çš„ Size å’Œä¸åŒçš„é¢œè‰²ä»£è¡¨ä¸åŒç‰©ä½“
            const itemGeo = new THREE.BufferGeometry();
            const itemPos = new Float32Array(ITEM_COUNT * 3);
            const itemOffset = new Float32Array(ITEM_COUNT * 3);
            for(let i=0; i<ITEM_COUNT; i++) {
                itemPos[i*3]=0; itemPos[i*3+1]=0; itemPos[i*3+2]=0;
                // éšæœºåˆ†å¸ƒåœ¨æ ‘å‘¨å›´
                const r = 20 + Math.random()*40;
                const theta = Math.random()*Math.PI*2;
                const y = (Math.random()-0.5)*100;
                itemOffset[i*3] = Math.cos(theta)*r;
                itemOffset[i*3+1] = y;
                itemOffset[i*3+2] = Math.sin(theta)*r;
            }
            itemGeo.setAttribute('position', new THREE.BufferAttribute(itemPos, 3));
            itemGeo.setAttribute('aBasePos', new THREE.BufferAttribute(itemOffset, 3));

            const itemMat = new THREE.ShaderMaterial({
                uniforms: { uTime: { value: 0 }, uFactor: { value: 0 }, uIsPhoto: { value: 0 } },
                vertexShader: `
                    uniform float uTime;
                    uniform float uFactor;
                    uniform float uIsPhoto;
                    attribute vec3 aBasePos;
                    void main() {
                        // å›´ç»•ä¸­å¿ƒæ—‹è½¬æ¼‚æµ®
                        float angle = uTime * 0.1 + aBasePos.y * 0.05;
                        vec3 pos;
                        pos.x = aBasePos.x * cos(angle) - aBasePos.z * sin(angle);
                        pos.z = aBasePos.x * sin(angle) + aBasePos.z * cos(angle);
                        pos.y = aBasePos.y + sin(uTime + aBasePos.x)*5.0;

                        // æ¡æ‹³æ—¶å¸é™„åˆ°æ ‘é‡Œï¼Œå¼ å¼€æ—¶é£å‡ºå»
                        float finalFactor = mix(uFactor, 1.0, uIsPhoto);
                        vec3 finalPos = pos * (0.5 + finalFactor * 1.5);

                        vec4 mvPosition = modelViewMatrix * vec4(finalPos, 1.0);
                        gl_Position = projectionMatrix * mvPosition;
                        gl_PointSize = 15.0 * (300.0 / -mvPosition.z);
                    }
                `,
                fragmentShader: `
                    void main() {
                        // ç®€å•çš„æ–¹å½¢ä»£è¡¨ç¤¼ç‰©/ä¿¡å° (å·æ‡’åšæ³•ï¼Œè¿œçœ‹åƒé—ªå…‰çš„çº¸ç‰‡)
                        vec2 coord = gl_PointCoord - vec2(0.5);
                        if(abs(coord.x) > 0.4 || abs(coord.y) > 0.4) discard;
                        gl_FragColor = vec4(1.0, 0.2, 0.2, 0.8); // çº¢è‰²ç¤¼ç‰©
                    }
                `,
                transparent: true
            });
            itemParticles = new THREE.Points(itemGeo, itemMat);
            scene.add(itemParticles);

            // --- ç…§ç‰‡å±•ç¤ºå¹³é¢ ---
            const pLoader = new THREE.TextureLoader();
            pLoader.crossOrigin = "Anonymous";
            photoMesh = new THREE.Mesh(
                new THREE.PlaneGeometry(1,1),
                new THREE.MeshBasicMaterial({ transparent: true, opacity: 0, side: THREE.DoubleSide })
            );
            scene.add(photoMesh);

            window.addEventListener('resize', onResize);
        }

        function onResize() {
            camera.aspect = window.innerWidth/window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // ================= äº¤äº’é€»è¾‘ =================
        // 1. åŠ è½½ç”»å»Š (åŠ¨æ€è¯»å–åç«¯ API)
        async function loadGallery() {
            const container = document.getElementById('gallery-container');
            const status = document.getElementById('loading-text');
            try {
                // æ ¸å¿ƒï¼šè¯·æ±‚ Node.js åç«¯ï¼Œåç«¯ä¼šè¿”å› static åŸŸåçš„ URL
                const res = await fetch('/api/images');
                const images = await res.json();
                
                container.innerHTML = '';
                if(images.length === 0) { status.innerText = "Bucketä¸ºç©º"; return; }

                images.forEach((imgData, idx) => {
                    const el = document.createElement('img');
                    // åŠ ä¸Šæ—¶é—´æˆ³é˜²ç¼“å­˜
                    el.src = imgData.url + "?t=" + Date.now();
                    el.className = 'gallery-item';
                    el.onclick = () => {
                        document.querySelectorAll('.gallery-item').forEach(e=>e.classList.remove('selected'));
                        el.classList.add('selected');
                        showPhoto(imgData.url);
                    };
                    if(idx===0) el.click();
                    container.appendChild(el);
                });
            } catch(e) {
                console.error(e);
                status.innerText = "è¿æ¥åç«¯å¤±è´¥: /api/images";
            }
        }

        // 2. æ˜¾ç¤ºç…§ç‰‡
        function showPhoto(url) {
            isPhotoMode = true;
            const loader = new THREE.TextureLoader();
            loader.crossOrigin = "Anonymous";
            loader.load(url + "?t=" + Date.now(), (tex) => {
                const aspect = tex.image.width / tex.image.height;
                photoMesh.geometry.dispose();
                photoMesh.geometry = new THREE.PlaneGeometry(40*aspect, 40);
                photoMesh.material.map = tex;
                photoMesh.material.needsUpdate = true;
            });
        }

        // 3. MediaPipe æ‰‹åŠ¿
        function initMediaPipe() {
            const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
            hands.setOptions({maxNumHands: 1, modelComplexity: 0, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5});
            
            hands.onResults(results => {
                if(results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                    isMouseMode = false;
                    const lm = results.multiHandLandmarks[0];
                    // è®¡ç®—å¼ å¼€ç¨‹åº¦
                    const d = Math.hypot(lm[8].x - lm[0].x, lm[8].y - lm[0].y); // é£ŸæŒ‡åˆ°æ‰‹è…•
                    // æ˜ å°„: 0.2(æ‹³) -> 0.5(å¼ )
                    let target = (d - 0.2) * 3.3; 
                    handOpenFactor += (Math.max(0, Math.min(1, target)) - handOpenFactor) * 0.1;
                    
                    const status = document.getElementById('status-text');
                    if(handOpenFactor < 0.3) status.innerText = "çŠ¶æ€: èšåˆæˆæ ‘ (æ¡æ‹³)";
                    else status.innerText = "çŠ¶æ€: ç²’å­çˆ†å‘ (å¼ æ‰‹)";
                    
                    // æåˆæ£€æµ‹
                    const pinch = Math.hypot(lm[4].x-lm[8].x, lm[4].y-lm[8].y);
                    if(pinch < 0.05) {
                        status.innerText = "çŠ¶æ€: æŠ“å–ç…§ç‰‡";
                        // è¿™é‡Œå¯ä»¥åŠ æ‹–åŠ¨é€»è¾‘ï¼Œæš‚æ—¶çœç•¥ä¿æŒæµç•…
                    }
                } else if(!isMouseMode) {
                    // æ²¡æ‰‹æ—¶è‡ªåŠ¨èšæ‹¢
                    handOpenFactor += (0 - handOpenFactor) * 0.05;
                    document.getElementById('status-text').innerText = "ç­‰å¾…æ‰‹åŠ¿...";
                }
            });

            const cam = new Camera(document.getElementById('input_video'), {
                onFrame: async () => { await hands.send({image: document.getElementById('input_video')}); },
                width: 320, height: 240
            });
            cam.start();
        }

        // 4. é¼ æ ‡å…¼å®¹
        document.addEventListener('mousemove', (e) => {
            // å¦‚æœæ²¡æ£€æµ‹åˆ°æ‘„åƒå¤´ï¼Œå…è®¸é¼ æ ‡æ§åˆ¶æ¼”ç¤º
            // ä¸Šä¸‹æ§åˆ¶èšæ•£ï¼Œå·¦å³æ§åˆ¶æ—‹è½¬
            // handOpenFactor = 1.0 - e.clientY/window.innerHeight;
        });

        // 5. åŠ¨ç”»å¾ªç¯
        function animate() {
            requestAnimationFrame(animate);
            const time = Date.now() * 0.001;

            if(goldParticles) {
                goldParticles.material.uniforms.uTime.value = time;
                goldParticles.material.uniforms.uFactor.value = handOpenFactor;
                // å¹³æ»‘åˆ‡æ¢ç…§ç‰‡æ¨¡å¼
                goldParticles.material.uniforms.uIsPhoto.value += ((isPhotoMode?1:0) - goldParticles.material.uniforms.uIsPhoto.value)*0.1;
                
                itemParticles.material.uniforms.uTime.value = time;
                itemParticles.material.uniforms.uFactor.value = handOpenFactor;
                itemParticles.material.uniforms.uIsPhoto.value = goldParticles.material.uniforms.uIsPhoto.value;
            }

            if(photoMesh) {
                const targetOp = isPhotoMode ? 1.0 : 0.0;
                photoMesh.material.opacity += (targetOp - photoMesh.material.opacity) * 0.1;
                if(isPhotoMode) {
                    photoMesh.position.y = Math.sin(time)*1.0; // æ‚¬æµ®
                    photoMesh.rotation.y = Math.sin(time*0.5)*0.1;
                }
            }

            renderer.render(scene, camera);
        }

        // å¯åŠ¨
        initThree();
        initMediaPipe();
        loadGallery();

    </script>
</body>
</html>